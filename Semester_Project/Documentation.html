<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, minimum-scale=1" name="viewport">
<meta content="pdoc 0.10.0" name="generator"/>
<title>Explorer API documentation</title>
<meta content="Project: Artificial Intelligence for Robotics
Author: Lukas Malek
Email: malek.luky@gmail.com
Date: February 2023" name="description"/>
<link as="style" crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" rel="preload stylesheet"/>
<link as="style" crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" rel="preload stylesheet"/>
<link as="style" crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" rel="stylesheet preload"/>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script crossorigin="" defer="" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</meta></head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Explorer</code></h1>
</header>
<section id="section-intro">
<p>Project: Artificial Intelligence for Robotics
Author: Lukas Malek
Email: malek.luky@gmail.com
Date: February 2023</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">"""
Project: Artificial Intelligence for Robotics
Author: Lukas Malek
Email: malek.luky@gmail.com
Date: February 2023
"""

# STANDARD LIBRARIES
import sys
import time
import threading as thread
import numpy as np
import matplotlib.pyplot as plt
import copy
 
# IMPORT EHAXPOD CLASSES
sys.path.append('../')
sys.path.append('hexapod_robot')
sys.path.append('hexapod_explorer')
import HexapodRobot 
import HexapodExplorer
from hexapod_robot.HexapodRobotConst import *
from messages import *
import pretty_errors
from lkh.invoke_LKH import solve_TSP

# CHOSE THE SETUP
planning = "p2" #p2/p3


 
###################################################################
# CLASS EXPLORER
###################################################################
class Explorer:
    """
    Class to represent an exploration agent
    """
    def __init__(self, robotID = 0):
        
        """
        Variables
        """
        print(time.strftime("%H:%M:%S"),"Initializing Explorer class...")
        self.gridmap = OccupancyGrid()
        self.gridmap.resolution = 0.1
        self.gridmap.width = 2 #m2 - otherwise default is 100
        self.gridmap.height = 2 #m2 - for m1 we need origin self.gridmap.origin = Pose(Vector3(-5.0,-5.0,0.0), Quaternion(1,0,0,0))
        self.gridmap.data = 0.5*np.ones((self.gridmap.height,self.gridmap.width)) #unknown (grey) area

        """
        Initialize values
        """
        self.frontiers = None
        self.frontier = None
        self.path = None
        self.path_simple = None
        self.stop = False # stop condition for the threads
        self.nav_goal = None
        self.collision = False

        """
        Connecting the simulator
        """
        self.robot = HexapodRobot.HexapodRobot(robotID)
        self.explor = HexapodExplorer.HexapodExplorer()
 
    def start(self):
        """
        Connect to the robot
        """
        print(time.strftime("%H:%M:%S"),"Starting threads...")
        self.robot.turn_on()
 
        """
        Start navigation thread
        """
        self.robot.start_navigation()
 
        """
        Start navigation thread
        """
        try:
            mapping_thread = thread.Thread(target=self.mapping)
            mapping_thread.start() 
        except:
            print(time.strftime("%H:%M:%S"),"Error: unable to start mapping thread")
            sys.exit(1)
 
        """
        Start planning thread
        """
        try:
            planning_thread = thread.Thread(target=self.planning)
            planning_thread.start() 
        except:
            print(time.strftime("%H:%M:%S"),"Error: unable to start planning thread")
            sys.exit(1)
 
        """
        Start trajectory following thread
        """
        try:
            traj_follow_thread = thread.Thread(target=self.trajectory_following)
            traj_follow_thread.start() 
        except:
            print(time.strftime("%H:%M:%S"),"Error: unable to start planning thread")
            sys.exit(1)
 
    def __del__(self):
        """
        Turn off the robot
        """
        self.robot.stop_navigation()
        self.robot.turn_off()
 
    def mapping(self):
        """
        Mapping thread for fusing the laser scans into the grid map
        """
        while not self.stop:
            """
            Obstacle growing: p1
            """
            time.sleep(THREAD_SLEEP)
            self.gridmap = self.explor.fuse_laser_scan(self.gridmap, self.robot.laser_scan_, self.robot.odometry_)
            self.gridmap.data = self.gridmap.data.reshape(self.gridmap.height, self.gridmap.width)
            self.gridmap_processed = self.explor.grow_obstacles(self.gridmap, ROBOT_SIZE)
            self.gridmap_astar = self.explor.grow_obstacles(self.gridmap, ROBOT_SIZE+0.13) # extra safety margin so we dont recalculate the path too often
        print(time.strftime("%H:%M:%S"),"Mapping thread terminated successfully!")
            

    def planning(self):
        """
        Find frontiers, select the next goal and path  
        """
        time.sleep(4*THREAD_SLEEP) #wait for map init
        timeout = 0 # timeout counter
        while not self.stop:
            time.sleep(THREAD_SLEEP) #wait for propper map init           
            """
            Check for collision from growing obstacles
            """
            self.collision = False
            if self.path is not None:
                for point in self.path.poses:
                    (x,y) = self.explor.world_to_map(point.position,self.gridmap)
                    if self.gridmap_processed.data[y,x] == 1:
                        self.robot.stop() #stop robot
                        self.collision = True
                        self.path_simple = None
                        self.path = None
                        self.frontier = None
                        print(time.strftime("%H:%M:%S"),"Collision detected! Rerouting...")
                        break

            """
            Check for timeout
            """
            if timeout &gt; 10:
                self.stop = True
                print(time.strftime("%H:%M:%S"),"No frontiers found 10 times in a row, stopping...")

            """
            Reroute only if collision is detected or if the goal is reached
            """
            self.frontiers = self.explor.remove_frontiers(self.gridmap_astar, self.frontiers) # remove frontiers using newly found obstacles
            if not self.collision and self.path_simple is not None:# and (self.robot.navigation_goal is not None or len(self.path_simple.poses) == 0):
                continue # look for frontiers only if collision or reached goal, don't look for frontiers last step before the goal
            
            """
            Find frontiers based on the chosen strategy
            p1: only find the frontiers
            p2: find frontiers and compute heuristic
            p3: only find the frontiers
            f1: only frontiers
            f2: fronteirs + KMeans approach (default for p1 and p3)
            f3: KMeans + information gain from each frontier
            """
            if planning == "p1" or planning=="p3":
                self.frontiers = self.explor.find_free_edge_frontiers(self.gridmap)
            elif planning == "p2":
                self.frontiers = self.explor.find_inf_frontiers(self.gridmap)
            self.frontiers = self.explor.remove_frontiers(self.gridmap_astar, self.frontiers) # remove frontiers in obstacles
            if len(self.frontiers) ==0:
                timeout+=1
                print(time.strftime("%H:%M:%S"),"No frontiers found. Timeout: ", timeout,"/10")
                continue #skip the frontier selection
            start = self.robot.odometry_.pose

            """
            p1: Select closest frontier and find the path
            """
            if planning == "p1":
                self.frontier = self.explor.closest_frontier(start, self.frontiers, self.gridmap_astar)
                self.path = self.explor.a_star(self.gridmap_astar, start, self.frontier) #we know that frontier is reachable
                if self.path is not None:
                    print(time.strftime("%H:%M:%S"),"New shortest path found!")
                    self.path_simple = self.explor.simplify_path(self.gridmap_astar, self.path)
                    timeout = 0
                else:
                    self.path_simple = None
                    timeout+=1
                    print(time.strftime("%H:%M:%S"),"No new path without collision! Timeout: ", timeout,"/10")
            """
            p2: Select the frontier with highest inforation gain
            """
            if planning == "p2":
                self.frontiers = sorted(self.frontiers, key=lambda x: x[1], reverse=True) #TODO: might be faster to just find the max
                for frontier in self.frontiers:
                    self.path = self.explor.a_star(self.gridmap_astar, start, frontier[0])
                    if self.path is not None:
                        self.frontier = frontier[0]
                        self.path_simple = self.explor.simplify_path(self.gridmap_astar, self.path)
                        timeout = 0
                        print(time.strftime("%H:%M:%S"),"New path with highest information gain found!")
                        break
                if self.path is None:
                    self.path_simple = None
                    timeout+=1
                    print(time.strftime("%H:%M:%S"),"No new path without collision! Timeout: ", timeout,"/10")
                    
            """
            p3: Select the best route using Travel Salesman Problem and distance matrix
            """
            if planning == "p3":
                if len(self.frontiers) == 1: # TSP cannot have dim &lt;3
                    goal = self.frontiers[0]
                else:
                    TSP_matrix = copy.deepcopy(self.frontiers)
                    TSP_matrix.insert(0, start)
                    distance_matrix = np.zeros((len(TSP_matrix), len(TSP_matrix)))
                    for row in range(len(TSP_matrix)): #rows are normqal
                        for col in range(1, len(TSP_matrix)): #column must be zero as we do not loop back to the start (so called open-ended)
                            path = self.explor.a_star(self.gridmap_astar, TSP_matrix[row], TSP_matrix[col])
                            if path is None:
                                distance_matrix[row][col] = 999999
                            else:
                                distance_matrix[row][col] = len(path.poses)
                    TSP_result = solve_TSP(distance_matrix) #[0, 7, 6, 3, 5, 4, 1, 2] order hot to follow frontiers
                    goal = TSP_matrix[TSP_result[1]] # first index so wwe skip the zero index, - because the frontiers are withotu domoetry positio
                self.path = self.explor.a_star(self.gridmap_astar, start, goal)
                if self.path is not None:
                    self.frontier = goal
                    self.path_simple = self.explor.simplify_path(self.gridmap_astar, self.path)
                    timeout = 0
                    print(time.strftime("%H:%M:%S"),"New best TSP path found!")
                else:
                    self.path_simple = None
                    timeout+=1
                    print(time.strftime("%H:%M:%S"),"No new path without collision! Timeout: ", timeout,"/10")


        print(time.strftime("%H:%M:%S"),"Planning thread terminated successfully!")


 
    def trajectory_following(self):
        """
        Assigns new goals to the robot when the previous one is reached
        """ 
        time.sleep(6*THREAD_SLEEP) #wait for plan init
        while not self.stop: 
            time.sleep(THREAD_SLEEP)
            if self.collision: # collision - new route
                self.robot.stop() #stop robot
                continue          
            if self.robot.navigation_goal is None and self.path_simple is not None:
                if len(self.path_simple.poses)==0: #reached the goal
                    self.robot.stop() #stop robot
                    self.path_simple = None
                    self.path = None
                    print(time.strftime("%H:%M:%S"), "Goal reached, waiting for new route")
                else: #cotninue with the old route
                    self.nav_goal = self.path_simple.poses.pop(0)
                    self.robot.goto(self.nav_goal)
                    print(time.strftime("%H:%M:%S"),"Goto: ", self.nav_goal.position.x, self.nav_goal.position.y)        
        print(time.strftime("%H:%M:%S"),"Trajectory following thread terminated successfully!")
            
 
 
if __name__ == "__main__":
    """
    Initiaite robot and start threads
    """
    expl = Explorer()
    expl.start()
    time.sleep(16*THREAD_SLEEP) #wait for everything to init

    """
    Initiate plotting
    """
    fig, (ax0, ax1, ax2) = plt.subplots(nrows=3, ncols=1, figsize=(5,10))
    plt.ion()
    ax0.set_xlabel('x[m]')
    ax0.set_ylabel('y[m]')
    ax1.set_xlabel('x[m]')
    ax1.set_ylabel('y[m]')
    ax2.set_xlabel('x[m]')
    ax2.set_ylabel('y[m]')
    ax0.set_aspect('equal', 'box')
    ax1.set_aspect('equal', 'box')
    ax2.set_aspect('equal', 'box')

    while not expl.stop:
        plt.pause(THREAD_SLEEP)
        ax0.cla() #clear the points from the previous iteration
        ax1.cla()
        ax2.cla()
        if expl.gridmap.data is not None and expl.gridmap_processed.data is not None and expl.gridmap_astar.data is not None: #grid
            expl.gridmap.plot(ax0)
            expl.gridmap_processed.plot(ax1)
            expl.gridmap_astar.plot(ax2)
        for frontier in expl.frontiers: #frontiers
            if type(frontier) != Pose:
                frontier = frontier[0]
            ax0.scatter(frontier.position.x, frontier.position.y,c='red')
            ax1.scatter(frontier.position.x, frontier.position.y,c='red')
            ax2.scatter(frontier.position.x, frontier.position.y,c='red')
        if expl.path is not None: #path
            expl.path.plot(ax0, style = 'point')
            expl.path.plot(ax1, style = 'point')
            expl.path.plot(ax2, style = 'point')
        if expl.path_simple is not None: #print simple path points
            for pose in expl.path_simple.poses:
                ax0.scatter(pose.position.x, pose.position.y,c='red', s=150, marker='x')
                ax1.scatter(pose.position.x, pose.position.y,c='red', s=150, marker='x')
                ax2.scatter(pose.position.x, pose.position.y,c='red', s=150, marker='x')
        if expl.robot.odometry_.pose is not None: #robot
            ax0.scatter(expl.robot.odometry_.pose.position.x, expl.robot.odometry_.pose.position.y,c='grey', s=150, marker='o')
            ax1.scatter(expl.robot.odometry_.pose.position.x, expl.robot.odometry_.pose.position.y,c='grey', s=150, marker='o')
            ax2.scatter(expl.robot.odometry_.pose.position.x, expl.robot.odometry_.pose.position.y,c='grey', s=150, marker='o')
        if expl.nav_goal is not None: #frontier
            ax0.scatter(expl.nav_goal.position.x, expl.nav_goal.position.y,c='black', s=150, marker='x')
            ax1.scatter(expl.nav_goal.position.x, expl.nav_goal.position.y,c='black', s=150, marker='x')
            ax2.scatter(expl.nav_goal.position.x, expl.nav_goal.position.y,c='black', s=150, marker='x')

        plt.show()
    expl.__del__() #turn it off
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Explorer.Explorer"><code class="flex name class">
<span>class <span class="ident">Explorer</span></span>
<span>(</span><span>robotID=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent an exploration agent</p>
<p>Variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Explorer:
    """
    Class to represent an exploration agent
    """
    def __init__(self, robotID = 0):
        
        """
        Variables
        """
        print(time.strftime("%H:%M:%S"),"Initializing Explorer class...")
        self.gridmap = OccupancyGrid()
        self.gridmap.resolution = 0.1
        self.gridmap.width = 2 #m2 - otherwise default is 100
        self.gridmap.height = 2 #m2 - for m1 we need origin self.gridmap.origin = Pose(Vector3(-5.0,-5.0,0.0), Quaternion(1,0,0,0))
        self.gridmap.data = 0.5*np.ones((self.gridmap.height,self.gridmap.width)) #unknown (grey) area

        """
        Initialize values
        """
        self.frontiers = None
        self.frontier = None
        self.path = None
        self.path_simple = None
        self.stop = False # stop condition for the threads
        self.nav_goal = None
        self.collision = False

        """
        Connecting the simulator
        """
        self.robot = HexapodRobot.HexapodRobot(robotID)
        self.explor = HexapodExplorer.HexapodExplorer()
 
    def start(self):
        """
        Connect to the robot
        """
        print(time.strftime("%H:%M:%S"),"Starting threads...")
        self.robot.turn_on()
 
        """
        Start navigation thread
        """
        self.robot.start_navigation()
 
        """
        Start navigation thread
        """
        try:
            mapping_thread = thread.Thread(target=self.mapping)
            mapping_thread.start() 
        except:
            print(time.strftime("%H:%M:%S"),"Error: unable to start mapping thread")
            sys.exit(1)
 
        """
        Start planning thread
        """
        try:
            planning_thread = thread.Thread(target=self.planning)
            planning_thread.start() 
        except:
            print(time.strftime("%H:%M:%S"),"Error: unable to start planning thread")
            sys.exit(1)
 
        """
        Start trajectory following thread
        """
        try:
            traj_follow_thread = thread.Thread(target=self.trajectory_following)
            traj_follow_thread.start() 
        except:
            print(time.strftime("%H:%M:%S"),"Error: unable to start planning thread")
            sys.exit(1)
 
    def __del__(self):
        """
        Turn off the robot
        """
        self.robot.stop_navigation()
        self.robot.turn_off()
 
    def mapping(self):
        """
        Mapping thread for fusing the laser scans into the grid map
        """
        while not self.stop:
            """
            Obstacle growing: p1
            """
            time.sleep(THREAD_SLEEP)
            self.gridmap = self.explor.fuse_laser_scan(self.gridmap, self.robot.laser_scan_, self.robot.odometry_)
            self.gridmap.data = self.gridmap.data.reshape(self.gridmap.height, self.gridmap.width)
            self.gridmap_processed = self.explor.grow_obstacles(self.gridmap, ROBOT_SIZE)
            self.gridmap_astar = self.explor.grow_obstacles(self.gridmap, ROBOT_SIZE+0.13) # extra safety margin so we dont recalculate the path too often
        print(time.strftime("%H:%M:%S"),"Mapping thread terminated successfully!")
            

    def planning(self):
        """
        Find frontiers, select the next goal and path  
        """
        time.sleep(4*THREAD_SLEEP) #wait for map init
        timeout = 0 # timeout counter
        while not self.stop:
            time.sleep(THREAD_SLEEP) #wait for propper map init           
            """
            Check for collision from growing obstacles
            """
            self.collision = False
            if self.path is not None:
                for point in self.path.poses:
                    (x,y) = self.explor.world_to_map(point.position,self.gridmap)
                    if self.gridmap_processed.data[y,x] == 1:
                        self.robot.stop() #stop robot
                        self.collision = True
                        self.path_simple = None
                        self.path = None
                        self.frontier = None
                        print(time.strftime("%H:%M:%S"),"Collision detected! Rerouting...")
                        break

            """
            Check for timeout
            """
            if timeout &gt; 10:
                self.stop = True
                print(time.strftime("%H:%M:%S"),"No frontiers found 10 times in a row, stopping...")

            """
            Reroute only if collision is detected or if the goal is reached
            """
            self.frontiers = self.explor.remove_frontiers(self.gridmap_astar, self.frontiers) # remove frontiers using newly found obstacles
            if not self.collision and self.path_simple is not None:# and (self.robot.navigation_goal is not None or len(self.path_simple.poses) == 0):
                continue # look for frontiers only if collision or reached goal, don't look for frontiers last step before the goal
            
            """
            Find frontiers based on the chosen strategy
            p1: only find the frontiers
            p2: find frontiers and compute heuristic
            p3: only find the frontiers
            f1: only frontiers
            f2: fronteirs + KMeans approach (default for p1 and p3)
            f3: KMeans + information gain from each frontier
            """
            if planning == "p1" or planning=="p3":
                self.frontiers = self.explor.find_free_edge_frontiers(self.gridmap)
            elif planning == "p2":
                self.frontiers = self.explor.find_inf_frontiers(self.gridmap)
            self.frontiers = self.explor.remove_frontiers(self.gridmap_astar, self.frontiers) # remove frontiers in obstacles
            if len(self.frontiers) ==0:
                timeout+=1
                print(time.strftime("%H:%M:%S"),"No frontiers found. Timeout: ", timeout,"/10")
                continue #skip the frontier selection
            start = self.robot.odometry_.pose

            """
            p1: Select closest frontier and find the path
            """
            if planning == "p1":
                self.frontier = self.explor.closest_frontier(start, self.frontiers, self.gridmap_astar)
                self.path = self.explor.a_star(self.gridmap_astar, start, self.frontier) #we know that frontier is reachable
                if self.path is not None:
                    print(time.strftime("%H:%M:%S"),"New shortest path found!")
                    self.path_simple = self.explor.simplify_path(self.gridmap_astar, self.path)
                    timeout = 0
                else:
                    self.path_simple = None
                    timeout+=1
                    print(time.strftime("%H:%M:%S"),"No new path without collision! Timeout: ", timeout,"/10")
            """
            p2: Select the frontier with highest inforation gain
            """
            if planning == "p2":
                self.frontiers = sorted(self.frontiers, key=lambda x: x[1], reverse=True) #TODO: might be faster to just find the max
                for frontier in self.frontiers:
                    self.path = self.explor.a_star(self.gridmap_astar, start, frontier[0])
                    if self.path is not None:
                        self.frontier = frontier[0]
                        self.path_simple = self.explor.simplify_path(self.gridmap_astar, self.path)
                        timeout = 0
                        print(time.strftime("%H:%M:%S"),"New path with highest information gain found!")
                        break
                if self.path is None:
                    self.path_simple = None
                    timeout+=1
                    print(time.strftime("%H:%M:%S"),"No new path without collision! Timeout: ", timeout,"/10")
                    
            """
            p3: Select the best route using Travel Salesman Problem and distance matrix
            """
            if planning == "p3":
                if len(self.frontiers) == 1: # TSP cannot have dim &lt;3
                    goal = self.frontiers[0]
                else:
                    TSP_matrix = copy.deepcopy(self.frontiers)
                    TSP_matrix.insert(0, start)
                    distance_matrix = np.zeros((len(TSP_matrix), len(TSP_matrix)))
                    for row in range(len(TSP_matrix)): #rows are normqal
                        for col in range(1, len(TSP_matrix)): #column must be zero as we do not loop back to the start (so called open-ended)
                            path = self.explor.a_star(self.gridmap_astar, TSP_matrix[row], TSP_matrix[col])
                            if path is None:
                                distance_matrix[row][col] = 999999
                            else:
                                distance_matrix[row][col] = len(path.poses)
                    TSP_result = solve_TSP(distance_matrix) #[0, 7, 6, 3, 5, 4, 1, 2] order hot to follow frontiers
                    goal = TSP_matrix[TSP_result[1]] # first index so wwe skip the zero index, - because the frontiers are withotu domoetry positio
                self.path = self.explor.a_star(self.gridmap_astar, start, goal)
                if self.path is not None:
                    self.frontier = goal
                    self.path_simple = self.explor.simplify_path(self.gridmap_astar, self.path)
                    timeout = 0
                    print(time.strftime("%H:%M:%S"),"New best TSP path found!")
                else:
                    self.path_simple = None
                    timeout+=1
                    print(time.strftime("%H:%M:%S"),"No new path without collision! Timeout: ", timeout,"/10")


        print(time.strftime("%H:%M:%S"),"Planning thread terminated successfully!")


 
    def trajectory_following(self):
        """
        Assigns new goals to the robot when the previous one is reached
        """ 
        time.sleep(6*THREAD_SLEEP) #wait for plan init
        while not self.stop: 
            time.sleep(THREAD_SLEEP)
            if self.collision: # collision - new route
                self.robot.stop() #stop robot
                continue          
            if self.robot.navigation_goal is None and self.path_simple is not None:
                if len(self.path_simple.poses)==0: #reached the goal
                    self.robot.stop() #stop robot
                    self.path_simple = None
                    self.path = None
                    print(time.strftime("%H:%M:%S"), "Goal reached, waiting for new route")
                else: #cotninue with the old route
                    self.nav_goal = self.path_simple.poses.pop(0)
                    self.robot.goto(self.nav_goal)
                    print(time.strftime("%H:%M:%S"),"Goto: ", self.nav_goal.position.x, self.nav_goal.position.y)        
        print(time.strftime("%H:%M:%S"),"Trajectory following thread terminated successfully!")</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="Explorer.Explorer.collision"><code class="name">var <span class="ident">collision</span></code></dt>
<dd>
<div class="desc"><p>Connecting the simulator</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Explorer.Explorer.mapping"><code class="name flex">
<span>def <span class="ident">mapping</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Mapping thread for fusing the laser scans into the grid map</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mapping(self):
    """
    Mapping thread for fusing the laser scans into the grid map
    """
    while not self.stop:
        """
        Obstacle growing: p1
        """
        time.sleep(THREAD_SLEEP)
        self.gridmap = self.explor.fuse_laser_scan(self.gridmap, self.robot.laser_scan_, self.robot.odometry_)
        self.gridmap.data = self.gridmap.data.reshape(self.gridmap.height, self.gridmap.width)
        self.gridmap_processed = self.explor.grow_obstacles(self.gridmap, ROBOT_SIZE)
        self.gridmap_astar = self.explor.grow_obstacles(self.gridmap, ROBOT_SIZE+0.13) # extra safety margin so we dont recalculate the path too often
    print(time.strftime("%H:%M:%S"),"Mapping thread terminated successfully!")</code></pre>
</details>
</dd>
<dt id="Explorer.Explorer.planning"><code class="name flex">
<span>def <span class="ident">planning</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find frontiers, select the next goal and path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def planning(self):
    """
    Find frontiers, select the next goal and path  
    """
    time.sleep(4*THREAD_SLEEP) #wait for map init
    timeout = 0 # timeout counter
    while not self.stop:
        time.sleep(THREAD_SLEEP) #wait for propper map init           
        """
        Check for collision from growing obstacles
        """
        self.collision = False
        if self.path is not None:
            for point in self.path.poses:
                (x,y) = self.explor.world_to_map(point.position,self.gridmap)
                if self.gridmap_processed.data[y,x] == 1:
                    self.robot.stop() #stop robot
                    self.collision = True
                    self.path_simple = None
                    self.path = None
                    self.frontier = None
                    print(time.strftime("%H:%M:%S"),"Collision detected! Rerouting...")
                    break

        """
        Check for timeout
        """
        if timeout &gt; 10:
            self.stop = True
            print(time.strftime("%H:%M:%S"),"No frontiers found 10 times in a row, stopping...")

        """
        Reroute only if collision is detected or if the goal is reached
        """
        self.frontiers = self.explor.remove_frontiers(self.gridmap_astar, self.frontiers) # remove frontiers using newly found obstacles
        if not self.collision and self.path_simple is not None:# and (self.robot.navigation_goal is not None or len(self.path_simple.poses) == 0):
            continue # look for frontiers only if collision or reached goal, don't look for frontiers last step before the goal
        
        """
        Find frontiers based on the chosen strategy
        p1: only find the frontiers
        p2: find frontiers and compute heuristic
        p3: only find the frontiers
        f1: only frontiers
        f2: fronteirs + KMeans approach (default for p1 and p3)
        f3: KMeans + information gain from each frontier
        """
        if planning == "p1" or planning=="p3":
            self.frontiers = self.explor.find_free_edge_frontiers(self.gridmap)
        elif planning == "p2":
            self.frontiers = self.explor.find_inf_frontiers(self.gridmap)
        self.frontiers = self.explor.remove_frontiers(self.gridmap_astar, self.frontiers) # remove frontiers in obstacles
        if len(self.frontiers) ==0:
            timeout+=1
            print(time.strftime("%H:%M:%S"),"No frontiers found. Timeout: ", timeout,"/10")
            continue #skip the frontier selection
        start = self.robot.odometry_.pose

        """
        p1: Select closest frontier and find the path
        """
        if planning == "p1":
            self.frontier = self.explor.closest_frontier(start, self.frontiers, self.gridmap_astar)
            self.path = self.explor.a_star(self.gridmap_astar, start, self.frontier) #we know that frontier is reachable
            if self.path is not None:
                print(time.strftime("%H:%M:%S"),"New shortest path found!")
                self.path_simple = self.explor.simplify_path(self.gridmap_astar, self.path)
                timeout = 0
            else:
                self.path_simple = None
                timeout+=1
                print(time.strftime("%H:%M:%S"),"No new path without collision! Timeout: ", timeout,"/10")
        """
        p2: Select the frontier with highest inforation gain
        """
        if planning == "p2":
            self.frontiers = sorted(self.frontiers, key=lambda x: x[1], reverse=True) #TODO: might be faster to just find the max
            for frontier in self.frontiers:
                self.path = self.explor.a_star(self.gridmap_astar, start, frontier[0])
                if self.path is not None:
                    self.frontier = frontier[0]
                    self.path_simple = self.explor.simplify_path(self.gridmap_astar, self.path)
                    timeout = 0
                    print(time.strftime("%H:%M:%S"),"New path with highest information gain found!")
                    break
            if self.path is None:
                self.path_simple = None
                timeout+=1
                print(time.strftime("%H:%M:%S"),"No new path without collision! Timeout: ", timeout,"/10")
                
        """
        p3: Select the best route using Travel Salesman Problem and distance matrix
        """
        if planning == "p3":
            if len(self.frontiers) == 1: # TSP cannot have dim &lt;3
                goal = self.frontiers[0]
            else:
                TSP_matrix = copy.deepcopy(self.frontiers)
                TSP_matrix.insert(0, start)
                distance_matrix = np.zeros((len(TSP_matrix), len(TSP_matrix)))
                for row in range(len(TSP_matrix)): #rows are normqal
                    for col in range(1, len(TSP_matrix)): #column must be zero as we do not loop back to the start (so called open-ended)
                        path = self.explor.a_star(self.gridmap_astar, TSP_matrix[row], TSP_matrix[col])
                        if path is None:
                            distance_matrix[row][col] = 999999
                        else:
                            distance_matrix[row][col] = len(path.poses)
                TSP_result = solve_TSP(distance_matrix) #[0, 7, 6, 3, 5, 4, 1, 2] order hot to follow frontiers
                goal = TSP_matrix[TSP_result[1]] # first index so wwe skip the zero index, - because the frontiers are withotu domoetry positio
            self.path = self.explor.a_star(self.gridmap_astar, start, goal)
            if self.path is not None:
                self.frontier = goal
                self.path_simple = self.explor.simplify_path(self.gridmap_astar, self.path)
                timeout = 0
                print(time.strftime("%H:%M:%S"),"New best TSP path found!")
            else:
                self.path_simple = None
                timeout+=1
                print(time.strftime("%H:%M:%S"),"No new path without collision! Timeout: ", timeout,"/10")


    print(time.strftime("%H:%M:%S"),"Planning thread terminated successfully!")</code></pre>
</details>
</dd>
<dt id="Explorer.Explorer.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to the robot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    """
    Connect to the robot
    """
    print(time.strftime("%H:%M:%S"),"Starting threads...")
    self.robot.turn_on()

    """
    Start navigation thread
    """
    self.robot.start_navigation()

    """
    Start navigation thread
    """
    try:
        mapping_thread = thread.Thread(target=self.mapping)
        mapping_thread.start() 
    except:
        print(time.strftime("%H:%M:%S"),"Error: unable to start mapping thread")
        sys.exit(1)

    """
    Start planning thread
    """
    try:
        planning_thread = thread.Thread(target=self.planning)
        planning_thread.start() 
    except:
        print(time.strftime("%H:%M:%S"),"Error: unable to start planning thread")
        sys.exit(1)

    """
    Start trajectory following thread
    """
    try:
        traj_follow_thread = thread.Thread(target=self.trajectory_following)
        traj_follow_thread.start() 
    except:
        print(time.strftime("%H:%M:%S"),"Error: unable to start planning thread")
        sys.exit(1)</code></pre>
</details>
</dd>
<dt id="Explorer.Explorer.trajectory_following"><code class="name flex">
<span>def <span class="ident">trajectory_following</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Assigns new goals to the robot when the previous one is reached</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trajectory_following(self):
    """
    Assigns new goals to the robot when the previous one is reached
    """ 
    time.sleep(6*THREAD_SLEEP) #wait for plan init
    while not self.stop: 
        time.sleep(THREAD_SLEEP)
        if self.collision: # collision - new route
            self.robot.stop() #stop robot
            continue          
        if self.robot.navigation_goal is None and self.path_simple is not None:
            if len(self.path_simple.poses)==0: #reached the goal
                self.robot.stop() #stop robot
                self.path_simple = None
                self.path = None
                print(time.strftime("%H:%M:%S"), "Goal reached, waiting for new route")
            else: #cotninue with the old route
                self.nav_goal = self.path_simple.poses.pop(0)
                self.robot.goto(self.nav_goal)
                print(time.strftime("%H:%M:%S"),"Goto: ", self.nav_goal.position.x, self.nav_goal.position.y)        
    print(time.strftime("%H:%M:%S"),"Trajectory following thread terminated successfully!")</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a href="#Explorer.Explorer" title="Explorer.Explorer">Explorer</a></code></h4>
<ul class="">
<li><code><a href="#Explorer.Explorer.collision" title="Explorer.Explorer.collision">collision</a></code></li>
<li><code><a href="#Explorer.Explorer.mapping" title="Explorer.Explorer.mapping">mapping</a></code></li>
<li><code><a href="#Explorer.Explorer.planning" title="Explorer.Explorer.planning">planning</a></code></li>
<li><code><a href="#Explorer.Explorer.start" title="Explorer.Explorer.start">start</a></code></li>
<li><code><a href="#Explorer.Explorer.trajectory_following" title="Explorer.Explorer.trajectory_following">trajectory_following</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html><!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, minimum-scale=1" name="viewport">
<meta content="pdoc 0.10.0" name="generator"/>
<title>HexapodController API documentation</title>
<meta content="Project: Artificial Intelligence for Robotics
Author: Lukas Malek
Email: malek.luky@gmail.com
Date: February 2023" name="description"/>
<link as="style" crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" rel="preload stylesheet"/>
<link as="style" crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" rel="preload stylesheet"/>
<link as="style" crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" rel="stylesheet preload"/>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script crossorigin="" defer="" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</meta></head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>HexapodController</code></h1>
</header>
<section id="section-intro">
<p>Project: Artificial Intelligence for Robotics
Author: Lukas Malek
Email: malek.luky@gmail.com
Date: February 2023</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">"""
Project: Artificial Intelligence for Robotics
Author: Lukas Malek
Email: malek.luky@gmail.com
Date: February 2023
"""

import numpy as np
from messages import *
import sys
sys.path.append('../')
sys.path.append('hexapod_robot')
import HexapodRobotConst as Constants

class HexapodController:
    def __init__(self):
        pass

    def goto(self, goal, odometry, collision):
        """
        Method to steer the robot towards the goal position given its current 
        odometry and collision status
        
        Args:
            goal: Pose of the robot goal
            odometry: Perceived odometry of the robot
            collision: bool of the robot collision status
        Returns:
            cmd: Twist steering command
        Notes:
            gx, gy = goal.x, goal.y
            cx, cy = odometry.position.x, odometry.position.y
            dst_to_target = np.linalg.norm(np.array([gx,cx,gy-cy])) #((gx-cx)**2-(gy-cy)**2)**(1/2)
            is_in_goal = dst_to_target &lt;Constants.DELTA_DISTANCE
        """
        cmd_msg = Twist() # zero velocity steering command
        if collision:
            cmd_msg.linear.x = 0
            cmd_msg.angular.z = 0
            return None
        if (goal is not None) and (odometry is not None):
            diff = goal.position-odometry.pose.position
            dst_to_target = (diff).norm()
            is_in_goal = dst_to_target &lt;Constants.DELTA_DISTANCE
            if is_in_goal:
                return None
            targ_h = np.arctan2(diff.y,diff.x)
            cur_h = odometry.pose.orientation.to_Euler()[0]
            diff_h = targ_h - cur_h
            diff_h = (diff_h + math.pi) % (2*math.pi) - math.pi
            if abs(diff_h) &gt; np.pi/6:
                cmd_msg.linear.x = 0
                cmd_msg.angular.z = 10*Constants.C_TURNING_SPEED*diff_h
            else:
                cmd_msg.linear.x = dst_to_target
                cmd_msg.angular.z = Constants.C_TURNING_SPEED*diff_h
        return cmd_msg     

    def stop(self):
        cmd_msg = Twist()
        cmd_msg.linear.x = 0
        cmd_msg.angular.z = 0</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="HexapodController.HexapodController"><code class="flex name class">
<span>class <span class="ident">HexapodController</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HexapodController:
    def __init__(self):
        pass

    def goto(self, goal, odometry, collision):
        """
        Method to steer the robot towards the goal position given its current 
        odometry and collision status
        
        Args:
            goal: Pose of the robot goal
            odometry: Perceived odometry of the robot
            collision: bool of the robot collision status
        Returns:
            cmd: Twist steering command
        Notes:
            gx, gy = goal.x, goal.y
            cx, cy = odometry.position.x, odometry.position.y
            dst_to_target = np.linalg.norm(np.array([gx,cx,gy-cy])) #((gx-cx)**2-(gy-cy)**2)**(1/2)
            is_in_goal = dst_to_target &lt;Constants.DELTA_DISTANCE
        """
        cmd_msg = Twist() # zero velocity steering command
        if collision:
            cmd_msg.linear.x = 0
            cmd_msg.angular.z = 0
            return None
        if (goal is not None) and (odometry is not None):
            diff = goal.position-odometry.pose.position
            dst_to_target = (diff).norm()
            is_in_goal = dst_to_target &lt;Constants.DELTA_DISTANCE
            if is_in_goal:
                return None
            targ_h = np.arctan2(diff.y,diff.x)
            cur_h = odometry.pose.orientation.to_Euler()[0]
            diff_h = targ_h - cur_h
            diff_h = (diff_h + math.pi) % (2*math.pi) - math.pi
            if abs(diff_h) &gt; np.pi/6:
                cmd_msg.linear.x = 0
                cmd_msg.angular.z = 10*Constants.C_TURNING_SPEED*diff_h
            else:
                cmd_msg.linear.x = dst_to_target
                cmd_msg.angular.z = Constants.C_TURNING_SPEED*diff_h
        return cmd_msg     

    def stop(self):
        cmd_msg = Twist()
        cmd_msg.linear.x = 0
        cmd_msg.angular.z = 0</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="HexapodController.HexapodController.goto"><code class="name flex">
<span>def <span class="ident">goto</span></span>(<span>self, goal, odometry, collision)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to steer the robot towards the goal position given its current
odometry and collision status</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>goal</code></strong></dt>
<dd>Pose of the robot goal</dd>
<dt><strong><code>odometry</code></strong></dt>
<dd>Perceived odometry of the robot</dd>
<dt><strong><code>collision</code></strong></dt>
<dd>bool of the robot collision status</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>cmd</code></dt>
<dd>Twist steering command</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>gx, gy = goal.x, goal.y
cx, cy = odometry.position.x, odometry.position.y
dst_to_target = np.linalg.norm(np.array([gx,cx,gy-cy])) #((gx-cx)<strong>2-(gy-cy)</strong>2)**(1/2)
is_in_goal = dst_to_target &lt;Constants.DELTA_DISTANCE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto(self, goal, odometry, collision):
    """
    Method to steer the robot towards the goal position given its current 
    odometry and collision status
    
    Args:
        goal: Pose of the robot goal
        odometry: Perceived odometry of the robot
        collision: bool of the robot collision status
    Returns:
        cmd: Twist steering command
    Notes:
        gx, gy = goal.x, goal.y
        cx, cy = odometry.position.x, odometry.position.y
        dst_to_target = np.linalg.norm(np.array([gx,cx,gy-cy])) #((gx-cx)**2-(gy-cy)**2)**(1/2)
        is_in_goal = dst_to_target &lt;Constants.DELTA_DISTANCE
    """
    cmd_msg = Twist() # zero velocity steering command
    if collision:
        cmd_msg.linear.x = 0
        cmd_msg.angular.z = 0
        return None
    if (goal is not None) and (odometry is not None):
        diff = goal.position-odometry.pose.position
        dst_to_target = (diff).norm()
        is_in_goal = dst_to_target &lt;Constants.DELTA_DISTANCE
        if is_in_goal:
            return None
        targ_h = np.arctan2(diff.y,diff.x)
        cur_h = odometry.pose.orientation.to_Euler()[0]
        diff_h = targ_h - cur_h
        diff_h = (diff_h + math.pi) % (2*math.pi) - math.pi
        if abs(diff_h) &gt; np.pi/6:
            cmd_msg.linear.x = 0
            cmd_msg.angular.z = 10*Constants.C_TURNING_SPEED*diff_h
        else:
            cmd_msg.linear.x = dst_to_target
            cmd_msg.angular.z = Constants.C_TURNING_SPEED*diff_h
    return cmd_msg     </code></pre>
</details>
</dd>
<dt id="HexapodController.HexapodController.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    cmd_msg = Twist()
    cmd_msg.linear.x = 0
    cmd_msg.angular.z = 0</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a href="#HexapodController.HexapodController" title="HexapodController.HexapodController">HexapodController</a></code></h4>
<ul class="">
<li><code><a href="#HexapodController.HexapodController.goto" title="HexapodController.HexapodController.goto">goto</a></code></li>
<li><code><a href="#HexapodController.HexapodController.stop" title="HexapodController.HexapodController.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html><!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, minimum-scale=1" name="viewport">
<meta content="pdoc 0.10.0" name="generator"/>
<title>HexapodExplorer API documentation</title>
<meta content="Project: Artificial Intelligence for Robotics
Author: Lukas Malek
Email: malek.luky@gmail.com
Date: February 2023" name="description"/>
<link as="style" crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" rel="preload stylesheet"/>
<link as="style" crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" rel="preload stylesheet"/>
<link as="style" crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" rel="stylesheet preload"/>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script crossorigin="" defer="" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</meta></head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>HexapodExplorer</code></h1>
</header>
<section id="section-intro">
<p>Project: Artificial Intelligence for Robotics
Author: Lukas Malek
Email: malek.luky@gmail.com
Date: February 2023</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">"""
Project: Artificial Intelligence for Robotics
Author: Lukas Malek
Email: malek.luky@gmail.com
Date: February 2023
"""

# STANDARD LIBRARIES
import math
import numpy as np
import copy
from messages import *
import matplotlib.pyplot as plt
import scipy.ndimage as ndimg
import heapq

# CUSTOM IMPORT
import sys
import heapq
import skimage.measure as skm
from sklearn.cluster import KMeans
#from lkh.invoke_LKH import solve_TSP
np.set_printoptions(threshold=sys.maxsize)  # print full numpy array
from hexapod_robot.HexapodRobotConst import *

# PRIORITY QUEUE
class PriorityQueue:
    def __init__(self):
        self.elements = []

    def empty(self):
        return len(self.elements) == 0

    def put(self, item, priority):
        heapq.heappush(self.elements, (priority, item))

    def pop(self):
        return heapq.heappop(self.elements)[1]

    def top(self):
        u = self.elements[0]
        return u[1]

    def topKey(self):
        u = self.elements[0]
        return u[0]

    def contains(self, element):
        ret = False
        for item in self.elements:
            if element == item[1]:
                ret = True
                break
        return ret

    def print_elements(self):
        return self.elements

    def remove(self, element):
        i = 0
        for item in self.elements:
            if element == item[1]:
                self.elements[i] = self.elements[-1]
                self.elements.pop()
                heapq.heapify(self.elements)
                break
            i += 1

    def arg(self,value):
        for item in self.elements:
            for subitem in item[0]:
                if value == subitem:
                    return item[1]

###################################################################
# CLASS HEXAPOD EXPLORER
###################################################################
class HexapodExplorer:

    def __init__(self):
        pass

    def print_path(self, path):
        """
        Method to print the path point by point
        """
        if path is not None:
            if len(path.poses)==0:
                print("Path is empty")
            for i, pose in enumerate(path.poses):
                print("Point",i,":",pose.position.x,pose.position.y)
        else:
            print("Path is None")

    def update_free(self, P_mi):
        """
        Method to calculate the Bayesian update of the free cell with the current occupancy probability value P_mi 

        Args:
            P_mi: float64 - current probability of the cell being occupied
        Returns:
            p_mi: float64 - updated probability of the cell being occupied
        """
        s_z_occ = 0
        s_z_free = 0.95  # to be sure that probability is never 0
        p_z_mi_occ = (1+s_z_occ-s_z_free)/2
        p_z_mi_free = 1-p_z_mi_occ
        p_mi = (p_z_mi_occ*P_mi)/((p_z_mi_occ*P_mi)+(p_z_mi_free*(1-P_mi)))
        return max(0.05, p_mi)  # never let p_mi get to 0

    def update_occupied(self, P_mi):
        """
        Method to calculate the Bayesian update of the occupied cell with the current occupancy probability value P_mi

        Args:
            P_mi: float64 - current probability of the cell being occupied
        Returns:
            p_mi: float64 - updated probability of the cell being occupied
        """
        s_z_occ = 0.95  # to be sure that probability is never 1
        s_z_free = 0
        p_z_mi_occ = (1+s_z_occ-s_z_free)/2
        p_z_mi_free = 1-p_z_mi_occ
        p_mi = (p_z_mi_occ*P_mi)/((p_z_mi_occ*P_mi)+(p_z_mi_free*(1-P_mi)))
        return min(p_mi, 0.95)  # never let p_mi get to 1

    def distance(self, start, end):
        '''
        Return the distance from the point A to the point B
        '''
        (x1, y1) = start
        (x2, y2) = end
        return math.sqrt(abs(x1 - x2)**2 + abs(y1 - y2)**2)

    def format_path(self, path, came_from, grid_map, start, goal):
        '''
        Return the path as requested in assignment as a list
        of positions[(x1, y1), (x2, y2), ...] At the moment the
        path is stored as the dicionary with at the format {(pos1):(pos2),..}
        and if you want to find the final path, you have to go backward,
        in other words start at the goal and than ask, "how I get there" till
        we will not reach the starting point
        '''
        path.poses.insert(0, self.map_to_world(
            goal, grid_map))  # Add goal!!
        coordinates = came_from.get(goal)
        while coordinates != start:
            pose = self.map_to_world(coordinates, grid_map)
            coordinates = came_from.get(coordinates)
            path.poses.insert(0, pose)
        pose = self.map_to_world(coordinates, grid_map)
        path.poses.insert(0, pose)  # Add start!!
        return path

    def neighbors_finder(self, current_pos, grid_map):
        '''
        Return the list of the neighbors of the current position
        return neighbors = [[(x1, y1), [(x2, y2), cost], ... ]
        '''
        neighbors = []
        (x, y) = current_pos
        if x==0 or y==0 or x==grid_map.width-1 or y==grid_map.width-1 or x==grid_map.height-1 or y==grid_map.height-1:
            return []
        for i in range(-1, 2):
            for j in range(-1, 2):
                if (i,j) != (0, 0) and grid_map.data[y + j, x + i] == 0:
                    neighbors.append((int(x + i), int(y + j))) #not on the edge
        return neighbors
    
    def world_to_map(self, point, grid_map):
        """
        Return the coordinates of the point in the map from the pose
        """
        if type(point) == Vector3:
            point = (point.x, point.y)
        else:
            point = (point[0], point[1]) #possible floating point error
        map_origin = np.array([grid_map.origin.position.x, grid_map.origin.position.y])
        res = (point - map_origin) / grid_map.resolution
        return tuple(np.round(res).astype(int))   

    def map_to_world(self, coordinates, grid_map):
        '''
        Return the pose from the map coordinates
        '''
        pose = Pose()
        pose.position.x = np.round(coordinates[0] * grid_map.resolution+grid_map.origin.position.x,decimals=3)
        pose.position.y = np.round(coordinates[1] * grid_map.resolution+grid_map.origin.position.y,decimals=3)
        return pose

    def a_star(self, grid_map, start_pose, goal_pose):
        '''
        Generates the path. The method returns a list of coordinates for the
        path. It must start with the starting position and end at the goal
        position [(x1, y1), (x2, y2),  ]. If there is no path, it should
        return None.
        '''
        if start_pose==None or goal_pose==None or start_pose==goal_pose:
            return None
        path = Path()
        frontier = list()
        start = self.world_to_map(start_pose.position, grid_map)
        goal = self.world_to_map(goal_pose.position, grid_map)
        heapq.heappush(frontier, (0, start))
        cost_so_far = dict() # {(x1,y1):cost1, (x2,y2):cost2, ..}
        cost_so_far[start] = 0
        came_from = dict()   # {(0, 0):None, (1, 2):(0, 1), ...}
        came_from[start] = None
        while frontier: # while not empty:
            current_pos = heapq.heappop(frontier)[1]
            if current_pos == goal:
                break
            neighbors = self.neighbors_finder(current_pos, grid_map)

            for next_pos in neighbors:
                new_cost = cost_so_far.get(
                    current_pos) + self.distance(next_pos, current_pos)
                if next_pos not in cost_so_far or new_cost &lt; cost_so_far.get(next_pos):
                    cost_so_far[next_pos] = new_cost
                    priority = new_cost + self.distance(next_pos, goal)
                    heapq.heappush(frontier, (priority, next_pos))
                    came_from[next_pos] = current_pos
        if current_pos == goal and start is not None and goal is not None:
            ret = self.format_path(path, came_from, grid_map, start, goal)
            return ret
        else:
            return None

    def closest_frontier(self, start, frontiers, gridmap_processed):
        '''
        Return the closest frontier from the list of frontiers
        '''
        shortest_path = np.inf
        ret_frontier = None
        for frontier in frontiers:
            path = self.a_star(gridmap_processed, start, frontier)
            if path is not None and len(path.poses) &lt; shortest_path:
                shortest_path = len(path.poses)
                ret_frontier = frontier
        return ret_frontier

    def remove_frontiers(self, gridmap, frontiers):
        if frontiers is not None:
            for frontier in frontiers: #remove frontiers which are in obstacle
                if type(frontier) != Pose:
                    frontier = frontier[0] #  where it contains also the information gain
                (x,y) = self.world_to_map(frontier.position,gridmap)
                if gridmap.data[y,x] == 1:
                    if type(frontiers[0]) == Pose:
                        frontiers = list(filter(lambda x: x != frontier, frontiers))
                    else:
                        frontiers = [item for item in frontiers if item[0] != frontier]
                        
        return frontiers

    def bresenham_line(self, start, goal):
        """
        Bresenham's line algorithm

        Args:
            start: (float64, float64) - start coordinate
            goal: (float64, float64) - goal coordinate
        Returns:
            (float64, float64) - interlying points between the start and goal coordinate
        """
        (x0, y0) = start
        (x1, y1) = goal
        line = []
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        x, y = x0, y0
        sx = -1 if x0 &gt; x1 else 1
        sy = -1 if y0 &gt; y1 else 1
        if dx &gt; dy:
            err = dx / 2.0
            while x != x1:
                line.append((x,y))
                err -= dy
                if err &lt; 0:
                    y += sy
                    err += dx
                x += sx
        else:
            err = dy / 2.0
            while y != y1:
                line.append((x,y))
                err -= dx
                if err &lt; 0:
                    x += sx
                    err += dy
                y += sy
        x = goal[0]
        y = goal[1]
        return line

    def plot_graph(self, grid_map):
        """
        Plot the graphs in case error occurs and we want to see the map
        """
        data = grid_map.data.reshape(grid_map.height, grid_map.width)
        _, ax = plt.subplots()
        plt.imshow(data, cmap='viridis')
        ax = plt.gca()
        ax.set_ylim(ax.get_ylim()[::-1])
        plt.colorbar()
        plt.xlabel('x[m]')
        plt.ylabel('y[m]')
        plt.title("pixel_plot")
        plt.show()

    def fuse_laser_scan(self, grid_map, laser_scan, odometry):
        """
        Method to fuse the laser scan data sampled by the robot with a given 
        odometry into the probabilistic occupancy grid map

        Args:
            grid_map_update: OccupancyGrid - gridmap to fuse te laser scan to
            laser_scan: LaserScan - laser scan perceived by the robot
            odometry: Odometry - perceived odometry of the robot
        Returns:
            grid_map_update: OccupancyGrid - gridmap updated with the laser scan data
        """
        grid_map_update = copy.deepcopy(grid_map)
        if laser_scan is not None and odometry is not None:
            laserscan_points = laser_scan.distances
            alpha_min = laser_scan.angle_min
            odometry_R = odometry.pose.orientation.to_R()
            odometry_x = odometry.pose.position.x
            odometry_y = odometry.pose.position.y
            free_points = list()
            occupied_points = list()
            for laserscan_sector, laserscan_sector_value in enumerate(laserscan_points):
                '''
                STEP 1: Project the laser scan points to x,y plane with respect to the robot heading
                '''
                if laserscan_sector_value &lt; laser_scan.range_min or laserscan_sector_value &gt; laser_scan.range_max:
                    continue # ignore invalid laserscan values
                theta_i = alpha_min + laserscan_sector*laser_scan.angle_increment
                point_x = laserscan_sector_value*np.cos(theta_i)
                point_y = laserscan_sector_value*np.sin(theta_i)

                '''
                STEP 2: Compensate for the robot odometry
                '''
                point_normalized = np.transpose(
                    np.array([point_x, point_y, 1]))
                point_x_global, point_y_global, _ = odometry_R @ point_normalized + \
                    np.array([odometry_x, odometry_y, 1])

                '''
                STEP 3: Transfer the points from the world coordinates to the map coordinates
                '''
                point_x_map, point_y_map = self.world_to_map(
                    [point_x_global, point_y_global], grid_map_update)

                '''
                STEP 4: Raytrace individual scanned points
                '''
                odometry_x_map, odometry_y_map = self.world_to_map(
                    [odometry_x, odometry_y], grid_map_update)
                pts = self.bresenham_line(
                    (odometry_x_map, odometry_y_map), (point_x_map, point_y_map))
                free_points.extend(pts)
                occupied_points.append((point_x_map, point_y_map))

            '''
            STEP 5: Dynamically resize the map
            '''
            data = grid_map_update.data.reshape(grid_map_update.height, grid_map_update.width)
            for (x, y) in [(odometry_x_map,odometry_y_map)] + occupied_points: # for the first loop we need to resize the map based on robot
                if x &lt; 0 or y &lt; 0 or data is None or x &gt;= grid_map.width or y &gt;= grid_map.height:
                    x_shift = min(0, x)     # negative coordinate -&gt; we need to shift the origin
                    y_shift = min(0, y)
                    new_height = max(grid_map.height if data is not None else 0, y+1) - y_shift
                    new_width = max(grid_map.width if data is not None else 0, x+1) - x_shift
                    new_origin = np.array([grid_map.origin.position.x, grid_map.origin.position.y]) + np.array([x_shift, y_shift]) * grid_map.resolution
                    new_data = 0.5 * np.ones((new_height, new_width))
                    if data is not None:
                        new_data[-y_shift:-y_shift+grid_map.height, -x_shift:-x_shift+grid_map.width] = data
                    grid_map_update.width = new_width
                    grid_map_update.height = new_height
                    grid_map_update.origin = Pose(Vector3(new_origin[0], new_origin[1], 0.0), Quaternion(1, 0, 0, 0))
                    grid_map_update.data = new_data.flatten()
                    return self.fuse_laser_scan(grid_map_update, laser_scan, odometry)

            '''
            STEP 6: Update the occupancy grid using the Bayesian update and the simplified laser scan sensor model
            '''
            for (x, y) in occupied_points:
                data[y, x] = self.update_occupied(data[y, x])
            for (x, y) in free_points:
                data[y, x] = self.update_free(data[y, x])
            grid_map_update.data = data.flatten() 
        return grid_map_update

    def grow_obstacles(self, grid_map, robot_size):
        """ Method to grow the obstacles to take into account the robot embodiment
        Args:
            grid_map: OccupancyGrid - gridmap for obstacle growing
            robot_size: float - size of the robot
        Returns:
            grid_map_grow: OccupancyGrid - gridmap with considered robot body embodiment
        Notes:
            use obstacle growing only on obstacles, not uknown areas
            filter all unknown areas moved to the end of the function
        """

        grid_map_grow = copy.deepcopy(grid_map)
        grid_map_grow.data[grid_map.data &gt; 0.5] = 1  # obstacles
        grid_map_grow.data[grid_map.data &lt;= 0.5] = 0  # free area
        kernel_size = round(robot_size/grid_map_grow.resolution)  # must be even
        r = round(kernel_size) # filter cells close to obstacles
        kernel = np.fromfunction(lambda x, y: ((x-r)**2 + (y-r)**2 &lt; r**2)*1, (2*r+1, 2*r+1), dtype=int).astype(np.uint8)
        grid_map_grow.data = ndimg.convolve(grid_map_grow.data, kernel)
        grid_map_grow.data[grid_map_grow.data &gt; 1] = 1
        grid_map_grow.data[grid_map.data == 0.5] = 1  # unknown area
        return grid_map_grow

    def simplify_path(self, grid_map, path):
        """
        Method to simplify the found path on the grid
        Founds the connected segments and remove unnecessary points

        Args:
            grid_map: OccupancyGrid - gridmap for obstacle growing
            path: Path - path to be simplified
        Returns:
            path_simple: Path - simplified path
        """
        if grid_map == None or path == None or len(path.poses)==0:
            return None
        path_simple = Path()
        path_simple.poses.append(path.poses[0]) # add the start pose
        i = 1
        while path_simple.poses[-1] != path.poses[-1]: #while goal not reached
            last_pose = path_simple.poses[-1] #last pose without collision
            for pose in path.poses[i::]:   
                end = path_simple.poses[-1]            
                bres_line = self.bresenham_line(self.world_to_map(end.position,grid_map),
                                                self.world_to_map(pose.position,grid_map))    
                
                collision = False
                for (x, y) in bres_line: #check for collision
                    if grid_map.data[y,x] != 0: # this is correct!
                        collision = True
                if collision == False:
                    last_pose = pose #update last_pose
                    i += 1
                    if pose == path.poses[-1]:  # goal is reached
                        path_simple.poses.append(last_pose)
                        break
                else:
                    path_simple.poses.append(last_pose)
                    break
            if len(bres_line)==1 and pose != path.poses[-1]:
                return None # looping scenario, frontier too close and inside obstacle???
        path_simple.poses.pop(0) # remove the start pose
        return path_simple

    def find_free_edge_frontiers(self, grid_map):
        """
        Method to find the free-edge frontiers (edge clusters between the free and unknown areas)

        Args:
            grid_map: OccupancyGrid - gridmap of the environment
        Returns:
            pose_list: Pose[] - list of selected frontiers
        """

        data = copy.deepcopy(grid_map.data)
        data[data == 0.5] = 10
        mask = np.array([[1, 1, 1], [1, 0, 1], [1, 1, 1]])
        data_c = ndimg.convolve(data, mask, mode='constant', cval=0.0)

        # Format result
        for (y, val1) in enumerate(data_c):
            for (x, val2) in enumerate(val1):
                if grid_map.data.reshape(grid_map.height, grid_map.width)[(y, x)] &lt; 0.5 and val2 &lt; 50 and val2 &gt;= 10:
                    data[(y, x)] = 1
                else:
                    data[(y, x)] = 0
        labeled_image, num_labels = skm.label(
            data, connectivity=2, return_num=True)

        # Final Labeling
        cluster = {}
        for label in range(1, num_labels+1):
            cluster[label] = []
        for x in range(0, labeled_image.shape[1]):
            for y in range(0, labeled_image.shape[0]):

                label = labeled_image[y, x]
                if label != 0:
                    cluster[label].append((x, y))
        pose_list = []
        for label, items in cluster.items():
            """
            f1 Implementation
            """
            # centroid = (0, 0)
            # for item in items:
            #     centroid = (centroid[0]+item[0], centroid[1]+item[1])
            # centroid = (centroid[0]/len(items), centroid[1]/len(items))
            # pose = self.map_to_world(
            #     [centroid[0], centroid[1]], grid_map)
            # pose_list.append(pose)

            """
            f2 Implementation
            """
            f = len(items)
            D = LASER_MAX_RANGE / grid_map.resolution
            n_r = np.floor(f/D + 0.5) +1
            kmeans = KMeans(n_clusters=int(n_r), max_iter=70, tol=1e-2, n_init=1).fit(items)
            for centroid in kmeans.cluster_centers_:
                pose_list.append(self.map_to_world(centroid, grid_map))
        return pose_list

    def find_inf_frontiers(self, grid_map):
        """
        f3 Implementation
        Method to find the information frontiers (frontiers with the highest information gain)
        Args:
            grid_map: OccupancyGrid - gridmap of the environment
        Returns:
            pose_list: Pose[] - list of selected frontiers
        """

        # Calculate entropy of each cell in the grid
        H = grid_map.data.copy()
        for row,row_val in enumerate(H):
            for col,col_val in enumerate(row_val): 
                p = H[row][col]
                if p == 0 or p == 1:
                    H[row][col] = 0
                else:
                    H[row][col] = -p * np.log(p) - (1-p) * np.log(1-p)

        # Find free frontiers
        frontiers = self.find_free_edge_frontiers(grid_map)

        # Calculate information gain of each frontier
        frontiers_weighted = []
        beams = 8
        for frontier in frontiers:
            frontier_cell = self.world_to_map(frontier.position, grid_map)

            # Calculate information gain along 8 beams from the frontier
            I_action = 0.0
            beam = Pose()
            for i in range(beams):
                beam.position.y = frontier.position.y + math.sin(i * math.pi/beams) * LASER_MAX_RANGE
                beam.position.x = frontier.position.x + math.cos(i * math.pi/beams) * LASER_MAX_RANGE
                beam_end_coord = self.world_to_map(beam.position, grid_map)
                beam_line = self.bresenham_line(frontier_cell, beam_end_coord)

                # Accumulate information gain along the beam
                for x, y in beam_line:
                    if (x &lt; 0 or x &gt;= grid_map.width or y &lt; 0 or y &gt;= grid_map.height) or grid_map.data[y, x] == 1:
                        break    # beam is out of bounds or hits an obstacle
                    I_action += H[y, x]
            frontiers_weighted.append((frontier, I_action))

        return frontiers_weighted</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="HexapodExplorer.HexapodExplorer"><code class="flex name class">
<span>class <span class="ident">HexapodExplorer</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HexapodExplorer:

    def __init__(self):
        pass

    def print_path(self, path):
        """
        Method to print the path point by point
        """
        if path is not None:
            if len(path.poses)==0:
                print("Path is empty")
            for i, pose in enumerate(path.poses):
                print("Point",i,":",pose.position.x,pose.position.y)
        else:
            print("Path is None")

    def update_free(self, P_mi):
        """
        Method to calculate the Bayesian update of the free cell with the current occupancy probability value P_mi 

        Args:
            P_mi: float64 - current probability of the cell being occupied
        Returns:
            p_mi: float64 - updated probability of the cell being occupied
        """
        s_z_occ = 0
        s_z_free = 0.95  # to be sure that probability is never 0
        p_z_mi_occ = (1+s_z_occ-s_z_free)/2
        p_z_mi_free = 1-p_z_mi_occ
        p_mi = (p_z_mi_occ*P_mi)/((p_z_mi_occ*P_mi)+(p_z_mi_free*(1-P_mi)))
        return max(0.05, p_mi)  # never let p_mi get to 0

    def update_occupied(self, P_mi):
        """
        Method to calculate the Bayesian update of the occupied cell with the current occupancy probability value P_mi

        Args:
            P_mi: float64 - current probability of the cell being occupied
        Returns:
            p_mi: float64 - updated probability of the cell being occupied
        """
        s_z_occ = 0.95  # to be sure that probability is never 1
        s_z_free = 0
        p_z_mi_occ = (1+s_z_occ-s_z_free)/2
        p_z_mi_free = 1-p_z_mi_occ
        p_mi = (p_z_mi_occ*P_mi)/((p_z_mi_occ*P_mi)+(p_z_mi_free*(1-P_mi)))
        return min(p_mi, 0.95)  # never let p_mi get to 1

    def distance(self, start, end):
        '''
        Return the distance from the point A to the point B
        '''
        (x1, y1) = start
        (x2, y2) = end
        return math.sqrt(abs(x1 - x2)**2 + abs(y1 - y2)**2)

    def format_path(self, path, came_from, grid_map, start, goal):
        '''
        Return the path as requested in assignment as a list
        of positions[(x1, y1), (x2, y2), ...] At the moment the
        path is stored as the dicionary with at the format {(pos1):(pos2),..}
        and if you want to find the final path, you have to go backward,
        in other words start at the goal and than ask, "how I get there" till
        we will not reach the starting point
        '''
        path.poses.insert(0, self.map_to_world(
            goal, grid_map))  # Add goal!!
        coordinates = came_from.get(goal)
        while coordinates != start:
            pose = self.map_to_world(coordinates, grid_map)
            coordinates = came_from.get(coordinates)
            path.poses.insert(0, pose)
        pose = self.map_to_world(coordinates, grid_map)
        path.poses.insert(0, pose)  # Add start!!
        return path

    def neighbors_finder(self, current_pos, grid_map):
        '''
        Return the list of the neighbors of the current position
        return neighbors = [[(x1, y1), [(x2, y2), cost], ... ]
        '''
        neighbors = []
        (x, y) = current_pos
        if x==0 or y==0 or x==grid_map.width-1 or y==grid_map.width-1 or x==grid_map.height-1 or y==grid_map.height-1:
            return []
        for i in range(-1, 2):
            for j in range(-1, 2):
                if (i,j) != (0, 0) and grid_map.data[y + j, x + i] == 0:
                    neighbors.append((int(x + i), int(y + j))) #not on the edge
        return neighbors
    
    def world_to_map(self, point, grid_map):
        """
        Return the coordinates of the point in the map from the pose
        """
        if type(point) == Vector3:
            point = (point.x, point.y)
        else:
            point = (point[0], point[1]) #possible floating point error
        map_origin = np.array([grid_map.origin.position.x, grid_map.origin.position.y])
        res = (point - map_origin) / grid_map.resolution
        return tuple(np.round(res).astype(int))   

    def map_to_world(self, coordinates, grid_map):
        '''
        Return the pose from the map coordinates
        '''
        pose = Pose()
        pose.position.x = np.round(coordinates[0] * grid_map.resolution+grid_map.origin.position.x,decimals=3)
        pose.position.y = np.round(coordinates[1] * grid_map.resolution+grid_map.origin.position.y,decimals=3)
        return pose

    def a_star(self, grid_map, start_pose, goal_pose):
        '''
        Generates the path. The method returns a list of coordinates for the
        path. It must start with the starting position and end at the goal
        position [(x1, y1), (x2, y2),  ]. If there is no path, it should
        return None.
        '''
        if start_pose==None or goal_pose==None or start_pose==goal_pose:
            return None
        path = Path()
        frontier = list()
        start = self.world_to_map(start_pose.position, grid_map)
        goal = self.world_to_map(goal_pose.position, grid_map)
        heapq.heappush(frontier, (0, start))
        cost_so_far = dict() # {(x1,y1):cost1, (x2,y2):cost2, ..}
        cost_so_far[start] = 0
        came_from = dict()   # {(0, 0):None, (1, 2):(0, 1), ...}
        came_from[start] = None
        while frontier: # while not empty:
            current_pos = heapq.heappop(frontier)[1]
            if current_pos == goal:
                break
            neighbors = self.neighbors_finder(current_pos, grid_map)

            for next_pos in neighbors:
                new_cost = cost_so_far.get(
                    current_pos) + self.distance(next_pos, current_pos)
                if next_pos not in cost_so_far or new_cost &lt; cost_so_far.get(next_pos):
                    cost_so_far[next_pos] = new_cost
                    priority = new_cost + self.distance(next_pos, goal)
                    heapq.heappush(frontier, (priority, next_pos))
                    came_from[next_pos] = current_pos
        if current_pos == goal and start is not None and goal is not None:
            ret = self.format_path(path, came_from, grid_map, start, goal)
            return ret
        else:
            return None

    def closest_frontier(self, start, frontiers, gridmap_processed):
        '''
        Return the closest frontier from the list of frontiers
        '''
        shortest_path = np.inf
        ret_frontier = None
        for frontier in frontiers:
            path = self.a_star(gridmap_processed, start, frontier)
            if path is not None and len(path.poses) &lt; shortest_path:
                shortest_path = len(path.poses)
                ret_frontier = frontier
        return ret_frontier

    def remove_frontiers(self, gridmap, frontiers):
        if frontiers is not None:
            for frontier in frontiers: #remove frontiers which are in obstacle
                if type(frontier) != Pose:
                    frontier = frontier[0] #  where it contains also the information gain
                (x,y) = self.world_to_map(frontier.position,gridmap)
                if gridmap.data[y,x] == 1:
                    if type(frontiers[0]) == Pose:
                        frontiers = list(filter(lambda x: x != frontier, frontiers))
                    else:
                        frontiers = [item for item in frontiers if item[0] != frontier]
                        
        return frontiers

    def bresenham_line(self, start, goal):
        """
        Bresenham's line algorithm

        Args:
            start: (float64, float64) - start coordinate
            goal: (float64, float64) - goal coordinate
        Returns:
            (float64, float64) - interlying points between the start and goal coordinate
        """
        (x0, y0) = start
        (x1, y1) = goal
        line = []
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        x, y = x0, y0
        sx = -1 if x0 &gt; x1 else 1
        sy = -1 if y0 &gt; y1 else 1
        if dx &gt; dy:
            err = dx / 2.0
            while x != x1:
                line.append((x,y))
                err -= dy
                if err &lt; 0:
                    y += sy
                    err += dx
                x += sx
        else:
            err = dy / 2.0
            while y != y1:
                line.append((x,y))
                err -= dx
                if err &lt; 0:
                    x += sx
                    err += dy
                y += sy
        x = goal[0]
        y = goal[1]
        return line

    def plot_graph(self, grid_map):
        """
        Plot the graphs in case error occurs and we want to see the map
        """
        data = grid_map.data.reshape(grid_map.height, grid_map.width)
        _, ax = plt.subplots()
        plt.imshow(data, cmap='viridis')
        ax = plt.gca()
        ax.set_ylim(ax.get_ylim()[::-1])
        plt.colorbar()
        plt.xlabel('x[m]')
        plt.ylabel('y[m]')
        plt.title("pixel_plot")
        plt.show()

    def fuse_laser_scan(self, grid_map, laser_scan, odometry):
        """
        Method to fuse the laser scan data sampled by the robot with a given 
        odometry into the probabilistic occupancy grid map

        Args:
            grid_map_update: OccupancyGrid - gridmap to fuse te laser scan to
            laser_scan: LaserScan - laser scan perceived by the robot
            odometry: Odometry - perceived odometry of the robot
        Returns:
            grid_map_update: OccupancyGrid - gridmap updated with the laser scan data
        """
        grid_map_update = copy.deepcopy(grid_map)
        if laser_scan is not None and odometry is not None:
            laserscan_points = laser_scan.distances
            alpha_min = laser_scan.angle_min
            odometry_R = odometry.pose.orientation.to_R()
            odometry_x = odometry.pose.position.x
            odometry_y = odometry.pose.position.y
            free_points = list()
            occupied_points = list()
            for laserscan_sector, laserscan_sector_value in enumerate(laserscan_points):
                '''
                STEP 1: Project the laser scan points to x,y plane with respect to the robot heading
                '''
                if laserscan_sector_value &lt; laser_scan.range_min or laserscan_sector_value &gt; laser_scan.range_max:
                    continue # ignore invalid laserscan values
                theta_i = alpha_min + laserscan_sector*laser_scan.angle_increment
                point_x = laserscan_sector_value*np.cos(theta_i)
                point_y = laserscan_sector_value*np.sin(theta_i)

                '''
                STEP 2: Compensate for the robot odometry
                '''
                point_normalized = np.transpose(
                    np.array([point_x, point_y, 1]))
                point_x_global, point_y_global, _ = odometry_R @ point_normalized + \
                    np.array([odometry_x, odometry_y, 1])

                '''
                STEP 3: Transfer the points from the world coordinates to the map coordinates
                '''
                point_x_map, point_y_map = self.world_to_map(
                    [point_x_global, point_y_global], grid_map_update)

                '''
                STEP 4: Raytrace individual scanned points
                '''
                odometry_x_map, odometry_y_map = self.world_to_map(
                    [odometry_x, odometry_y], grid_map_update)
                pts = self.bresenham_line(
                    (odometry_x_map, odometry_y_map), (point_x_map, point_y_map))
                free_points.extend(pts)
                occupied_points.append((point_x_map, point_y_map))

            '''
            STEP 5: Dynamically resize the map
            '''
            data = grid_map_update.data.reshape(grid_map_update.height, grid_map_update.width)
            for (x, y) in [(odometry_x_map,odometry_y_map)] + occupied_points: # for the first loop we need to resize the map based on robot
                if x &lt; 0 or y &lt; 0 or data is None or x &gt;= grid_map.width or y &gt;= grid_map.height:
                    x_shift = min(0, x)     # negative coordinate -&gt; we need to shift the origin
                    y_shift = min(0, y)
                    new_height = max(grid_map.height if data is not None else 0, y+1) - y_shift
                    new_width = max(grid_map.width if data is not None else 0, x+1) - x_shift
                    new_origin = np.array([grid_map.origin.position.x, grid_map.origin.position.y]) + np.array([x_shift, y_shift]) * grid_map.resolution
                    new_data = 0.5 * np.ones((new_height, new_width))
                    if data is not None:
                        new_data[-y_shift:-y_shift+grid_map.height, -x_shift:-x_shift+grid_map.width] = data
                    grid_map_update.width = new_width
                    grid_map_update.height = new_height
                    grid_map_update.origin = Pose(Vector3(new_origin[0], new_origin[1], 0.0), Quaternion(1, 0, 0, 0))
                    grid_map_update.data = new_data.flatten()
                    return self.fuse_laser_scan(grid_map_update, laser_scan, odometry)

            '''
            STEP 6: Update the occupancy grid using the Bayesian update and the simplified laser scan sensor model
            '''
            for (x, y) in occupied_points:
                data[y, x] = self.update_occupied(data[y, x])
            for (x, y) in free_points:
                data[y, x] = self.update_free(data[y, x])
            grid_map_update.data = data.flatten() 
        return grid_map_update

    def grow_obstacles(self, grid_map, robot_size):
        """ Method to grow the obstacles to take into account the robot embodiment
        Args:
            grid_map: OccupancyGrid - gridmap for obstacle growing
            robot_size: float - size of the robot
        Returns:
            grid_map_grow: OccupancyGrid - gridmap with considered robot body embodiment
        Notes:
            use obstacle growing only on obstacles, not uknown areas
            filter all unknown areas moved to the end of the function
        """

        grid_map_grow = copy.deepcopy(grid_map)
        grid_map_grow.data[grid_map.data &gt; 0.5] = 1  # obstacles
        grid_map_grow.data[grid_map.data &lt;= 0.5] = 0  # free area
        kernel_size = round(robot_size/grid_map_grow.resolution)  # must be even
        r = round(kernel_size) # filter cells close to obstacles
        kernel = np.fromfunction(lambda x, y: ((x-r)**2 + (y-r)**2 &lt; r**2)*1, (2*r+1, 2*r+1), dtype=int).astype(np.uint8)
        grid_map_grow.data = ndimg.convolve(grid_map_grow.data, kernel)
        grid_map_grow.data[grid_map_grow.data &gt; 1] = 1
        grid_map_grow.data[grid_map.data == 0.5] = 1  # unknown area
        return grid_map_grow

    def simplify_path(self, grid_map, path):
        """
        Method to simplify the found path on the grid
        Founds the connected segments and remove unnecessary points

        Args:
            grid_map: OccupancyGrid - gridmap for obstacle growing
            path: Path - path to be simplified
        Returns:
            path_simple: Path - simplified path
        """
        if grid_map == None or path == None or len(path.poses)==0:
            return None
        path_simple = Path()
        path_simple.poses.append(path.poses[0]) # add the start pose
        i = 1
        while path_simple.poses[-1] != path.poses[-1]: #while goal not reached
            last_pose = path_simple.poses[-1] #last pose without collision
            for pose in path.poses[i::]:   
                end = path_simple.poses[-1]            
                bres_line = self.bresenham_line(self.world_to_map(end.position,grid_map),
                                                self.world_to_map(pose.position,grid_map))    
                
                collision = False
                for (x, y) in bres_line: #check for collision
                    if grid_map.data[y,x] != 0: # this is correct!
                        collision = True
                if collision == False:
                    last_pose = pose #update last_pose
                    i += 1
                    if pose == path.poses[-1]:  # goal is reached
                        path_simple.poses.append(last_pose)
                        break
                else:
                    path_simple.poses.append(last_pose)
                    break
            if len(bres_line)==1 and pose != path.poses[-1]:
                return None # looping scenario, frontier too close and inside obstacle???
        path_simple.poses.pop(0) # remove the start pose
        return path_simple

    def find_free_edge_frontiers(self, grid_map):
        """
        Method to find the free-edge frontiers (edge clusters between the free and unknown areas)

        Args:
            grid_map: OccupancyGrid - gridmap of the environment
        Returns:
            pose_list: Pose[] - list of selected frontiers
        """

        data = copy.deepcopy(grid_map.data)
        data[data == 0.5] = 10
        mask = np.array([[1, 1, 1], [1, 0, 1], [1, 1, 1]])
        data_c = ndimg.convolve(data, mask, mode='constant', cval=0.0)

        # Format result
        for (y, val1) in enumerate(data_c):
            for (x, val2) in enumerate(val1):
                if grid_map.data.reshape(grid_map.height, grid_map.width)[(y, x)] &lt; 0.5 and val2 &lt; 50 and val2 &gt;= 10:
                    data[(y, x)] = 1
                else:
                    data[(y, x)] = 0
        labeled_image, num_labels = skm.label(
            data, connectivity=2, return_num=True)

        # Final Labeling
        cluster = {}
        for label in range(1, num_labels+1):
            cluster[label] = []
        for x in range(0, labeled_image.shape[1]):
            for y in range(0, labeled_image.shape[0]):

                label = labeled_image[y, x]
                if label != 0:
                    cluster[label].append((x, y))
        pose_list = []
        for label, items in cluster.items():
            """
            f1 Implementation
            """
            # centroid = (0, 0)
            # for item in items:
            #     centroid = (centroid[0]+item[0], centroid[1]+item[1])
            # centroid = (centroid[0]/len(items), centroid[1]/len(items))
            # pose = self.map_to_world(
            #     [centroid[0], centroid[1]], grid_map)
            # pose_list.append(pose)

            """
            f2 Implementation
            """
            f = len(items)
            D = LASER_MAX_RANGE / grid_map.resolution
            n_r = np.floor(f/D + 0.5) +1
            kmeans = KMeans(n_clusters=int(n_r), max_iter=70, tol=1e-2, n_init=1).fit(items)
            for centroid in kmeans.cluster_centers_:
                pose_list.append(self.map_to_world(centroid, grid_map))
        return pose_list

    def find_inf_frontiers(self, grid_map):
        """
        f3 Implementation
        Method to find the information frontiers (frontiers with the highest information gain)
        Args:
            grid_map: OccupancyGrid - gridmap of the environment
        Returns:
            pose_list: Pose[] - list of selected frontiers
        """

        # Calculate entropy of each cell in the grid
        H = grid_map.data.copy()
        for row,row_val in enumerate(H):
            for col,col_val in enumerate(row_val): 
                p = H[row][col]
                if p == 0 or p == 1:
                    H[row][col] = 0
                else:
                    H[row][col] = -p * np.log(p) - (1-p) * np.log(1-p)

        # Find free frontiers
        frontiers = self.find_free_edge_frontiers(grid_map)

        # Calculate information gain of each frontier
        frontiers_weighted = []
        beams = 8
        for frontier in frontiers:
            frontier_cell = self.world_to_map(frontier.position, grid_map)

            # Calculate information gain along 8 beams from the frontier
            I_action = 0.0
            beam = Pose()
            for i in range(beams):
                beam.position.y = frontier.position.y + math.sin(i * math.pi/beams) * LASER_MAX_RANGE
                beam.position.x = frontier.position.x + math.cos(i * math.pi/beams) * LASER_MAX_RANGE
                beam_end_coord = self.world_to_map(beam.position, grid_map)
                beam_line = self.bresenham_line(frontier_cell, beam_end_coord)

                # Accumulate information gain along the beam
                for x, y in beam_line:
                    if (x &lt; 0 or x &gt;= grid_map.width or y &lt; 0 or y &gt;= grid_map.height) or grid_map.data[y, x] == 1:
                        break    # beam is out of bounds or hits an obstacle
                    I_action += H[y, x]
            frontiers_weighted.append((frontier, I_action))

        return frontiers_weighted</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="HexapodExplorer.HexapodExplorer.a_star"><code class="name flex">
<span>def <span class="ident">a_star</span></span>(<span>self, grid_map, start_pose, goal_pose)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the path. The method returns a list of coordinates for the
path. It must start with the starting position and end at the goal
position [(x1, y1), (x2, y2),  ]. If there is no path, it should
return None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def a_star(self, grid_map, start_pose, goal_pose):
    '''
    Generates the path. The method returns a list of coordinates for the
    path. It must start with the starting position and end at the goal
    position [(x1, y1), (x2, y2),  ]. If there is no path, it should
    return None.
    '''
    if start_pose==None or goal_pose==None or start_pose==goal_pose:
        return None
    path = Path()
    frontier = list()
    start = self.world_to_map(start_pose.position, grid_map)
    goal = self.world_to_map(goal_pose.position, grid_map)
    heapq.heappush(frontier, (0, start))
    cost_so_far = dict() # {(x1,y1):cost1, (x2,y2):cost2, ..}
    cost_so_far[start] = 0
    came_from = dict()   # {(0, 0):None, (1, 2):(0, 1), ...}
    came_from[start] = None
    while frontier: # while not empty:
        current_pos = heapq.heappop(frontier)[1]
        if current_pos == goal:
            break
        neighbors = self.neighbors_finder(current_pos, grid_map)

        for next_pos in neighbors:
            new_cost = cost_so_far.get(
                current_pos) + self.distance(next_pos, current_pos)
            if next_pos not in cost_so_far or new_cost &lt; cost_so_far.get(next_pos):
                cost_so_far[next_pos] = new_cost
                priority = new_cost + self.distance(next_pos, goal)
                heapq.heappush(frontier, (priority, next_pos))
                came_from[next_pos] = current_pos
    if current_pos == goal and start is not None and goal is not None:
        ret = self.format_path(path, came_from, grid_map, start, goal)
        return ret
    else:
        return None</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.bresenham_line"><code class="name flex">
<span>def <span class="ident">bresenham_line</span></span>(<span>self, start, goal)</span>
</code></dt>
<dd>
<div class="desc"><p>Bresenham's line algorithm</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>(float64, float64) - start coordinate</dd>
<dt><strong><code>goal</code></strong></dt>
<dd>(float64, float64) - goal coordinate</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(float64, float64) - interlying points between the start and goal coordinate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bresenham_line(self, start, goal):
    """
    Bresenham's line algorithm

    Args:
        start: (float64, float64) - start coordinate
        goal: (float64, float64) - goal coordinate
    Returns:
        (float64, float64) - interlying points between the start and goal coordinate
    """
    (x0, y0) = start
    (x1, y1) = goal
    line = []
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    x, y = x0, y0
    sx = -1 if x0 &gt; x1 else 1
    sy = -1 if y0 &gt; y1 else 1
    if dx &gt; dy:
        err = dx / 2.0
        while x != x1:
            line.append((x,y))
            err -= dy
            if err &lt; 0:
                y += sy
                err += dx
            x += sx
    else:
        err = dy / 2.0
        while y != y1:
            line.append((x,y))
            err -= dx
            if err &lt; 0:
                x += sx
                err += dy
            y += sy
    x = goal[0]
    y = goal[1]
    return line</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.closest_frontier"><code class="name flex">
<span>def <span class="ident">closest_frontier</span></span>(<span>self, start, frontiers, gridmap_processed)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the closest frontier from the list of frontiers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closest_frontier(self, start, frontiers, gridmap_processed):
    '''
    Return the closest frontier from the list of frontiers
    '''
    shortest_path = np.inf
    ret_frontier = None
    for frontier in frontiers:
        path = self.a_star(gridmap_processed, start, frontier)
        if path is not None and len(path.poses) &lt; shortest_path:
            shortest_path = len(path.poses)
            ret_frontier = frontier
    return ret_frontier</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>self, start, end)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the distance from the point A to the point B</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance(self, start, end):
    '''
    Return the distance from the point A to the point B
    '''
    (x1, y1) = start
    (x2, y2) = end
    return math.sqrt(abs(x1 - x2)**2 + abs(y1 - y2)**2)</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.find_free_edge_frontiers"><code class="name flex">
<span>def <span class="ident">find_free_edge_frontiers</span></span>(<span>self, grid_map)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to find the free-edge frontiers (edge clusters between the free and unknown areas)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_map</code></strong></dt>
<dd>OccupancyGrid - gridmap of the environment</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pose_list</code></dt>
<dd>Pose[] - list of selected frontiers</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_free_edge_frontiers(self, grid_map):
    """
    Method to find the free-edge frontiers (edge clusters between the free and unknown areas)

    Args:
        grid_map: OccupancyGrid - gridmap of the environment
    Returns:
        pose_list: Pose[] - list of selected frontiers
    """

    data = copy.deepcopy(grid_map.data)
    data[data == 0.5] = 10
    mask = np.array([[1, 1, 1], [1, 0, 1], [1, 1, 1]])
    data_c = ndimg.convolve(data, mask, mode='constant', cval=0.0)

    # Format result
    for (y, val1) in enumerate(data_c):
        for (x, val2) in enumerate(val1):
            if grid_map.data.reshape(grid_map.height, grid_map.width)[(y, x)] &lt; 0.5 and val2 &lt; 50 and val2 &gt;= 10:
                data[(y, x)] = 1
            else:
                data[(y, x)] = 0
    labeled_image, num_labels = skm.label(
        data, connectivity=2, return_num=True)

    # Final Labeling
    cluster = {}
    for label in range(1, num_labels+1):
        cluster[label] = []
    for x in range(0, labeled_image.shape[1]):
        for y in range(0, labeled_image.shape[0]):

            label = labeled_image[y, x]
            if label != 0:
                cluster[label].append((x, y))
    pose_list = []
    for label, items in cluster.items():
        """
        f1 Implementation
        """
        # centroid = (0, 0)
        # for item in items:
        #     centroid = (centroid[0]+item[0], centroid[1]+item[1])
        # centroid = (centroid[0]/len(items), centroid[1]/len(items))
        # pose = self.map_to_world(
        #     [centroid[0], centroid[1]], grid_map)
        # pose_list.append(pose)

        """
        f2 Implementation
        """
        f = len(items)
        D = LASER_MAX_RANGE / grid_map.resolution
        n_r = np.floor(f/D + 0.5) +1
        kmeans = KMeans(n_clusters=int(n_r), max_iter=70, tol=1e-2, n_init=1).fit(items)
        for centroid in kmeans.cluster_centers_:
            pose_list.append(self.map_to_world(centroid, grid_map))
    return pose_list</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.find_inf_frontiers"><code class="name flex">
<span>def <span class="ident">find_inf_frontiers</span></span>(<span>self, grid_map)</span>
</code></dt>
<dd>
<div class="desc"><p>f3 Implementation
Method to find the information frontiers (frontiers with the highest information gain)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_map</code></strong></dt>
<dd>OccupancyGrid - gridmap of the environment</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pose_list</code></dt>
<dd>Pose[] - list of selected frontiers</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_inf_frontiers(self, grid_map):
    """
    f3 Implementation
    Method to find the information frontiers (frontiers with the highest information gain)
    Args:
        grid_map: OccupancyGrid - gridmap of the environment
    Returns:
        pose_list: Pose[] - list of selected frontiers
    """

    # Calculate entropy of each cell in the grid
    H = grid_map.data.copy()
    for row,row_val in enumerate(H):
        for col,col_val in enumerate(row_val): 
            p = H[row][col]
            if p == 0 or p == 1:
                H[row][col] = 0
            else:
                H[row][col] = -p * np.log(p) - (1-p) * np.log(1-p)

    # Find free frontiers
    frontiers = self.find_free_edge_frontiers(grid_map)

    # Calculate information gain of each frontier
    frontiers_weighted = []
    beams = 8
    for frontier in frontiers:
        frontier_cell = self.world_to_map(frontier.position, grid_map)

        # Calculate information gain along 8 beams from the frontier
        I_action = 0.0
        beam = Pose()
        for i in range(beams):
            beam.position.y = frontier.position.y + math.sin(i * math.pi/beams) * LASER_MAX_RANGE
            beam.position.x = frontier.position.x + math.cos(i * math.pi/beams) * LASER_MAX_RANGE
            beam_end_coord = self.world_to_map(beam.position, grid_map)
            beam_line = self.bresenham_line(frontier_cell, beam_end_coord)

            # Accumulate information gain along the beam
            for x, y in beam_line:
                if (x &lt; 0 or x &gt;= grid_map.width or y &lt; 0 or y &gt;= grid_map.height) or grid_map.data[y, x] == 1:
                    break    # beam is out of bounds or hits an obstacle
                I_action += H[y, x]
        frontiers_weighted.append((frontier, I_action))

    return frontiers_weighted</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.format_path"><code class="name flex">
<span>def <span class="ident">format_path</span></span>(<span>self, path, came_from, grid_map, start, goal)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the path as requested in assignment as a list
of positions[(x1, y1), (x2, y2), ] At the moment the
path is stored as the dicionary with at the format {(pos1):(pos2),..}
and if you want to find the final path, you have to go backward,
in other words start at the goal and than ask, "how I get there" till
we will not reach the starting point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_path(self, path, came_from, grid_map, start, goal):
    '''
    Return the path as requested in assignment as a list
    of positions[(x1, y1), (x2, y2), ...] At the moment the
    path is stored as the dicionary with at the format {(pos1):(pos2),..}
    and if you want to find the final path, you have to go backward,
    in other words start at the goal and than ask, "how I get there" till
    we will not reach the starting point
    '''
    path.poses.insert(0, self.map_to_world(
        goal, grid_map))  # Add goal!!
    coordinates = came_from.get(goal)
    while coordinates != start:
        pose = self.map_to_world(coordinates, grid_map)
        coordinates = came_from.get(coordinates)
        path.poses.insert(0, pose)
    pose = self.map_to_world(coordinates, grid_map)
    path.poses.insert(0, pose)  # Add start!!
    return path</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.fuse_laser_scan"><code class="name flex">
<span>def <span class="ident">fuse_laser_scan</span></span>(<span>self, grid_map, laser_scan, odometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to fuse the laser scan data sampled by the robot with a given
odometry into the probabilistic occupancy grid map</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_map_update</code></strong></dt>
<dd>OccupancyGrid - gridmap to fuse te laser scan to</dd>
<dt><strong><code>laser_scan</code></strong></dt>
<dd>LaserScan - laser scan perceived by the robot</dd>
<dt><strong><code>odometry</code></strong></dt>
<dd>Odometry - perceived odometry of the robot</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>grid_map_update</code></dt>
<dd>OccupancyGrid - gridmap updated with the laser scan data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fuse_laser_scan(self, grid_map, laser_scan, odometry):
    """
    Method to fuse the laser scan data sampled by the robot with a given 
    odometry into the probabilistic occupancy grid map

    Args:
        grid_map_update: OccupancyGrid - gridmap to fuse te laser scan to
        laser_scan: LaserScan - laser scan perceived by the robot
        odometry: Odometry - perceived odometry of the robot
    Returns:
        grid_map_update: OccupancyGrid - gridmap updated with the laser scan data
    """
    grid_map_update = copy.deepcopy(grid_map)
    if laser_scan is not None and odometry is not None:
        laserscan_points = laser_scan.distances
        alpha_min = laser_scan.angle_min
        odometry_R = odometry.pose.orientation.to_R()
        odometry_x = odometry.pose.position.x
        odometry_y = odometry.pose.position.y
        free_points = list()
        occupied_points = list()
        for laserscan_sector, laserscan_sector_value in enumerate(laserscan_points):
            '''
            STEP 1: Project the laser scan points to x,y plane with respect to the robot heading
            '''
            if laserscan_sector_value &lt; laser_scan.range_min or laserscan_sector_value &gt; laser_scan.range_max:
                continue # ignore invalid laserscan values
            theta_i = alpha_min + laserscan_sector*laser_scan.angle_increment
            point_x = laserscan_sector_value*np.cos(theta_i)
            point_y = laserscan_sector_value*np.sin(theta_i)

            '''
            STEP 2: Compensate for the robot odometry
            '''
            point_normalized = np.transpose(
                np.array([point_x, point_y, 1]))
            point_x_global, point_y_global, _ = odometry_R @ point_normalized + \
                np.array([odometry_x, odometry_y, 1])

            '''
            STEP 3: Transfer the points from the world coordinates to the map coordinates
            '''
            point_x_map, point_y_map = self.world_to_map(
                [point_x_global, point_y_global], grid_map_update)

            '''
            STEP 4: Raytrace individual scanned points
            '''
            odometry_x_map, odometry_y_map = self.world_to_map(
                [odometry_x, odometry_y], grid_map_update)
            pts = self.bresenham_line(
                (odometry_x_map, odometry_y_map), (point_x_map, point_y_map))
            free_points.extend(pts)
            occupied_points.append((point_x_map, point_y_map))

        '''
        STEP 5: Dynamically resize the map
        '''
        data = grid_map_update.data.reshape(grid_map_update.height, grid_map_update.width)
        for (x, y) in [(odometry_x_map,odometry_y_map)] + occupied_points: # for the first loop we need to resize the map based on robot
            if x &lt; 0 or y &lt; 0 or data is None or x &gt;= grid_map.width or y &gt;= grid_map.height:
                x_shift = min(0, x)     # negative coordinate -&gt; we need to shift the origin
                y_shift = min(0, y)
                new_height = max(grid_map.height if data is not None else 0, y+1) - y_shift
                new_width = max(grid_map.width if data is not None else 0, x+1) - x_shift
                new_origin = np.array([grid_map.origin.position.x, grid_map.origin.position.y]) + np.array([x_shift, y_shift]) * grid_map.resolution
                new_data = 0.5 * np.ones((new_height, new_width))
                if data is not None:
                    new_data[-y_shift:-y_shift+grid_map.height, -x_shift:-x_shift+grid_map.width] = data
                grid_map_update.width = new_width
                grid_map_update.height = new_height
                grid_map_update.origin = Pose(Vector3(new_origin[0], new_origin[1], 0.0), Quaternion(1, 0, 0, 0))
                grid_map_update.data = new_data.flatten()
                return self.fuse_laser_scan(grid_map_update, laser_scan, odometry)

        '''
        STEP 6: Update the occupancy grid using the Bayesian update and the simplified laser scan sensor model
        '''
        for (x, y) in occupied_points:
            data[y, x] = self.update_occupied(data[y, x])
        for (x, y) in free_points:
            data[y, x] = self.update_free(data[y, x])
        grid_map_update.data = data.flatten() 
    return grid_map_update</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.grow_obstacles"><code class="name flex">
<span>def <span class="ident">grow_obstacles</span></span>(<span>self, grid_map, robot_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to grow the obstacles to take into account the robot embodiment</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_map</code></strong></dt>
<dd>OccupancyGrid - gridmap for obstacle growing</dd>
<dt><strong><code>robot_size</code></strong></dt>
<dd>float - size of the robot</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>grid_map_grow</code></dt>
<dd>OccupancyGrid - gridmap with considered robot body embodiment</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>use obstacle growing only on obstacles, not uknown areas
filter all unknown areas moved to the end of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grow_obstacles(self, grid_map, robot_size):
    """ Method to grow the obstacles to take into account the robot embodiment
    Args:
        grid_map: OccupancyGrid - gridmap for obstacle growing
        robot_size: float - size of the robot
    Returns:
        grid_map_grow: OccupancyGrid - gridmap with considered robot body embodiment
    Notes:
        use obstacle growing only on obstacles, not uknown areas
        filter all unknown areas moved to the end of the function
    """

    grid_map_grow = copy.deepcopy(grid_map)
    grid_map_grow.data[grid_map.data &gt; 0.5] = 1  # obstacles
    grid_map_grow.data[grid_map.data &lt;= 0.5] = 0  # free area
    kernel_size = round(robot_size/grid_map_grow.resolution)  # must be even
    r = round(kernel_size) # filter cells close to obstacles
    kernel = np.fromfunction(lambda x, y: ((x-r)**2 + (y-r)**2 &lt; r**2)*1, (2*r+1, 2*r+1), dtype=int).astype(np.uint8)
    grid_map_grow.data = ndimg.convolve(grid_map_grow.data, kernel)
    grid_map_grow.data[grid_map_grow.data &gt; 1] = 1
    grid_map_grow.data[grid_map.data == 0.5] = 1  # unknown area
    return grid_map_grow</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.map_to_world"><code class="name flex">
<span>def <span class="ident">map_to_world</span></span>(<span>self, coordinates, grid_map)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the pose from the map coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_to_world(self, coordinates, grid_map):
    '''
    Return the pose from the map coordinates
    '''
    pose = Pose()
    pose.position.x = np.round(coordinates[0] * grid_map.resolution+grid_map.origin.position.x,decimals=3)
    pose.position.y = np.round(coordinates[1] * grid_map.resolution+grid_map.origin.position.y,decimals=3)
    return pose</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.neighbors_finder"><code class="name flex">
<span>def <span class="ident">neighbors_finder</span></span>(<span>self, current_pos, grid_map)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of the neighbors of the current position
return neighbors = [[(x1, y1), [(x2, y2), cost],  ]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neighbors_finder(self, current_pos, grid_map):
    '''
    Return the list of the neighbors of the current position
    return neighbors = [[(x1, y1), [(x2, y2), cost], ... ]
    '''
    neighbors = []
    (x, y) = current_pos
    if x==0 or y==0 or x==grid_map.width-1 or y==grid_map.width-1 or x==grid_map.height-1 or y==grid_map.height-1:
        return []
    for i in range(-1, 2):
        for j in range(-1, 2):
            if (i,j) != (0, 0) and grid_map.data[y + j, x + i] == 0:
                neighbors.append((int(x + i), int(y + j))) #not on the edge
    return neighbors</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.plot_graph"><code class="name flex">
<span>def <span class="ident">plot_graph</span></span>(<span>self, grid_map)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the graphs in case error occurs and we want to see the map</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_graph(self, grid_map):
    """
    Plot the graphs in case error occurs and we want to see the map
    """
    data = grid_map.data.reshape(grid_map.height, grid_map.width)
    _, ax = plt.subplots()
    plt.imshow(data, cmap='viridis')
    ax = plt.gca()
    ax.set_ylim(ax.get_ylim()[::-1])
    plt.colorbar()
    plt.xlabel('x[m]')
    plt.ylabel('y[m]')
    plt.title("pixel_plot")
    plt.show()</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.print_path"><code class="name flex">
<span>def <span class="ident">print_path</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to print the path point by point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_path(self, path):
    """
    Method to print the path point by point
    """
    if path is not None:
        if len(path.poses)==0:
            print("Path is empty")
        for i, pose in enumerate(path.poses):
            print("Point",i,":",pose.position.x,pose.position.y)
    else:
        print("Path is None")</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.remove_frontiers"><code class="name flex">
<span>def <span class="ident">remove_frontiers</span></span>(<span>self, gridmap, frontiers)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_frontiers(self, gridmap, frontiers):
    if frontiers is not None:
        for frontier in frontiers: #remove frontiers which are in obstacle
            if type(frontier) != Pose:
                frontier = frontier[0] #  where it contains also the information gain
            (x,y) = self.world_to_map(frontier.position,gridmap)
            if gridmap.data[y,x] == 1:
                if type(frontiers[0]) == Pose:
                    frontiers = list(filter(lambda x: x != frontier, frontiers))
                else:
                    frontiers = [item for item in frontiers if item[0] != frontier]
                    
    return frontiers</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.simplify_path"><code class="name flex">
<span>def <span class="ident">simplify_path</span></span>(<span>self, grid_map, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to simplify the found path on the grid
Founds the connected segments and remove unnecessary points</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_map</code></strong></dt>
<dd>OccupancyGrid - gridmap for obstacle growing</dd>
<dt><strong><code>path</code></strong></dt>
<dd>Path - path to be simplified</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>path_simple</code></dt>
<dd>Path - simplified path</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplify_path(self, grid_map, path):
    """
    Method to simplify the found path on the grid
    Founds the connected segments and remove unnecessary points

    Args:
        grid_map: OccupancyGrid - gridmap for obstacle growing
        path: Path - path to be simplified
    Returns:
        path_simple: Path - simplified path
    """
    if grid_map == None or path == None or len(path.poses)==0:
        return None
    path_simple = Path()
    path_simple.poses.append(path.poses[0]) # add the start pose
    i = 1
    while path_simple.poses[-1] != path.poses[-1]: #while goal not reached
        last_pose = path_simple.poses[-1] #last pose without collision
        for pose in path.poses[i::]:   
            end = path_simple.poses[-1]            
            bres_line = self.bresenham_line(self.world_to_map(end.position,grid_map),
                                            self.world_to_map(pose.position,grid_map))    
            
            collision = False
            for (x, y) in bres_line: #check for collision
                if grid_map.data[y,x] != 0: # this is correct!
                    collision = True
            if collision == False:
                last_pose = pose #update last_pose
                i += 1
                if pose == path.poses[-1]:  # goal is reached
                    path_simple.poses.append(last_pose)
                    break
            else:
                path_simple.poses.append(last_pose)
                break
        if len(bres_line)==1 and pose != path.poses[-1]:
            return None # looping scenario, frontier too close and inside obstacle???
    path_simple.poses.pop(0) # remove the start pose
    return path_simple</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.update_free"><code class="name flex">
<span>def <span class="ident">update_free</span></span>(<span>self, P_mi)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to calculate the Bayesian update of the free cell with the current occupancy probability value P_mi </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P_mi</code></strong></dt>
<dd>float64 - current probability of the cell being occupied</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>p_mi</code></dt>
<dd>float64 - updated probability of the cell being occupied</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_free(self, P_mi):
    """
    Method to calculate the Bayesian update of the free cell with the current occupancy probability value P_mi 

    Args:
        P_mi: float64 - current probability of the cell being occupied
    Returns:
        p_mi: float64 - updated probability of the cell being occupied
    """
    s_z_occ = 0
    s_z_free = 0.95  # to be sure that probability is never 0
    p_z_mi_occ = (1+s_z_occ-s_z_free)/2
    p_z_mi_free = 1-p_z_mi_occ
    p_mi = (p_z_mi_occ*P_mi)/((p_z_mi_occ*P_mi)+(p_z_mi_free*(1-P_mi)))
    return max(0.05, p_mi)  # never let p_mi get to 0</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.update_occupied"><code class="name flex">
<span>def <span class="ident">update_occupied</span></span>(<span>self, P_mi)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to calculate the Bayesian update of the occupied cell with the current occupancy probability value P_mi</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P_mi</code></strong></dt>
<dd>float64 - current probability of the cell being occupied</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>p_mi</code></dt>
<dd>float64 - updated probability of the cell being occupied</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_occupied(self, P_mi):
    """
    Method to calculate the Bayesian update of the occupied cell with the current occupancy probability value P_mi

    Args:
        P_mi: float64 - current probability of the cell being occupied
    Returns:
        p_mi: float64 - updated probability of the cell being occupied
    """
    s_z_occ = 0.95  # to be sure that probability is never 1
    s_z_free = 0
    p_z_mi_occ = (1+s_z_occ-s_z_free)/2
    p_z_mi_free = 1-p_z_mi_occ
    p_mi = (p_z_mi_occ*P_mi)/((p_z_mi_occ*P_mi)+(p_z_mi_free*(1-P_mi)))
    return min(p_mi, 0.95)  # never let p_mi get to 1</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.HexapodExplorer.world_to_map"><code class="name flex">
<span>def <span class="ident">world_to_map</span></span>(<span>self, point, grid_map)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the coordinates of the point in the map from the pose</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def world_to_map(self, point, grid_map):
    """
    Return the coordinates of the point in the map from the pose
    """
    if type(point) == Vector3:
        point = (point.x, point.y)
    else:
        point = (point[0], point[1]) #possible floating point error
    map_origin = np.array([grid_map.origin.position.x, grid_map.origin.position.y])
    res = (point - map_origin) / grid_map.resolution
    return tuple(np.round(res).astype(int))   </code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="HexapodExplorer.PriorityQueue"><code class="flex name class">
<span>class <span class="ident">PriorityQueue</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PriorityQueue:
    def __init__(self):
        self.elements = []

    def empty(self):
        return len(self.elements) == 0

    def put(self, item, priority):
        heapq.heappush(self.elements, (priority, item))

    def pop(self):
        return heapq.heappop(self.elements)[1]

    def top(self):
        u = self.elements[0]
        return u[1]

    def topKey(self):
        u = self.elements[0]
        return u[0]

    def contains(self, element):
        ret = False
        for item in self.elements:
            if element == item[1]:
                ret = True
                break
        return ret

    def print_elements(self):
        return self.elements

    def remove(self, element):
        i = 0
        for item in self.elements:
            if element == item[1]:
                self.elements[i] = self.elements[-1]
                self.elements.pop()
                heapq.heapify(self.elements)
                break
            i += 1

    def arg(self,value):
        for item in self.elements:
            for subitem in item[0]:
                if value == subitem:
                    return item[1]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="HexapodExplorer.PriorityQueue.arg"><code class="name flex">
<span>def <span class="ident">arg</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arg(self,value):
    for item in self.elements:
        for subitem in item[0]:
            if value == subitem:
                return item[1]</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.PriorityQueue.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, element)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains(self, element):
    ret = False
    for item in self.elements:
        if element == item[1]:
            ret = True
            break
    return ret</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.PriorityQueue.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empty(self):
    return len(self.elements) == 0</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.PriorityQueue.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self):
    return heapq.heappop(self.elements)[1]</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.PriorityQueue.print_elements"><code class="name flex">
<span>def <span class="ident">print_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_elements(self):
    return self.elements</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.PriorityQueue.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self, item, priority)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put(self, item, priority):
    heapq.heappush(self.elements, (priority, item))</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.PriorityQueue.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, element)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, element):
    i = 0
    for item in self.elements:
        if element == item[1]:
            self.elements[i] = self.elements[-1]
            self.elements.pop()
            heapq.heapify(self.elements)
            break
        i += 1</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.PriorityQueue.top"><code class="name flex">
<span>def <span class="ident">top</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def top(self):
    u = self.elements[0]
    return u[1]</code></pre>
</details>
</dd>
<dt id="HexapodExplorer.PriorityQueue.topKey"><code class="name flex">
<span>def <span class="ident">topKey</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def topKey(self):
    u = self.elements[0]
    return u[0]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a href="#HexapodExplorer.HexapodExplorer" title="HexapodExplorer.HexapodExplorer">HexapodExplorer</a></code></h4>
<ul class="">
<li><code><a href="#HexapodExplorer.HexapodExplorer.a_star" title="HexapodExplorer.HexapodExplorer.a_star">a_star</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.bresenham_line" title="HexapodExplorer.HexapodExplorer.bresenham_line">bresenham_line</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.closest_frontier" title="HexapodExplorer.HexapodExplorer.closest_frontier">closest_frontier</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.distance" title="HexapodExplorer.HexapodExplorer.distance">distance</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.find_free_edge_frontiers" title="HexapodExplorer.HexapodExplorer.find_free_edge_frontiers">find_free_edge_frontiers</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.find_inf_frontiers" title="HexapodExplorer.HexapodExplorer.find_inf_frontiers">find_inf_frontiers</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.format_path" title="HexapodExplorer.HexapodExplorer.format_path">format_path</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.fuse_laser_scan" title="HexapodExplorer.HexapodExplorer.fuse_laser_scan">fuse_laser_scan</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.grow_obstacles" title="HexapodExplorer.HexapodExplorer.grow_obstacles">grow_obstacles</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.map_to_world" title="HexapodExplorer.HexapodExplorer.map_to_world">map_to_world</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.neighbors_finder" title="HexapodExplorer.HexapodExplorer.neighbors_finder">neighbors_finder</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.plot_graph" title="HexapodExplorer.HexapodExplorer.plot_graph">plot_graph</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.print_path" title="HexapodExplorer.HexapodExplorer.print_path">print_path</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.remove_frontiers" title="HexapodExplorer.HexapodExplorer.remove_frontiers">remove_frontiers</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.simplify_path" title="HexapodExplorer.HexapodExplorer.simplify_path">simplify_path</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.update_free" title="HexapodExplorer.HexapodExplorer.update_free">update_free</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.update_occupied" title="HexapodExplorer.HexapodExplorer.update_occupied">update_occupied</a></code></li>
<li><code><a href="#HexapodExplorer.HexapodExplorer.world_to_map" title="HexapodExplorer.HexapodExplorer.world_to_map">world_to_map</a></code></li>
</ul>
</li>
<li>
<h4><code><a href="#HexapodExplorer.PriorityQueue" title="HexapodExplorer.PriorityQueue">PriorityQueue</a></code></h4>
<ul class="two-column">
<li><code><a href="#HexapodExplorer.PriorityQueue.arg" title="HexapodExplorer.PriorityQueue.arg">arg</a></code></li>
<li><code><a href="#HexapodExplorer.PriorityQueue.contains" title="HexapodExplorer.PriorityQueue.contains">contains</a></code></li>
<li><code><a href="#HexapodExplorer.PriorityQueue.empty" title="HexapodExplorer.PriorityQueue.empty">empty</a></code></li>
<li><code><a href="#HexapodExplorer.PriorityQueue.pop" title="HexapodExplorer.PriorityQueue.pop">pop</a></code></li>
<li><code><a href="#HexapodExplorer.PriorityQueue.print_elements" title="HexapodExplorer.PriorityQueue.print_elements">print_elements</a></code></li>
<li><code><a href="#HexapodExplorer.PriorityQueue.put" title="HexapodExplorer.PriorityQueue.put">put</a></code></li>
<li><code><a href="#HexapodExplorer.PriorityQueue.remove" title="HexapodExplorer.PriorityQueue.remove">remove</a></code></li>
<li><code><a href="#HexapodExplorer.PriorityQueue.top" title="HexapodExplorer.PriorityQueue.top">top</a></code></li>
<li><code><a href="#HexapodExplorer.PriorityQueue.topKey" title="HexapodExplorer.PriorityQueue.topKey">topKey</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html><!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, minimum-scale=1" name="viewport">
<meta content="pdoc 0.10.0" name="generator"/>
<title>HexapodRobot API documentation</title>
<meta content="Project: Artificial Intelligence for Robotics
Author: Lukas Malek
Email: malek.luky@gmail.com
Date: February 2023" name="description"/>
<link as="style" crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" rel="preload stylesheet"/>
<link as="style" crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" rel="preload stylesheet"/>
<link as="style" crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" rel="stylesheet preload"/>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script crossorigin="" defer="" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</meta></head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>HexapodRobot</code></h1>
</header>
<section id="section-intro">
<p>Project: Artificial Intelligence for Robotics
Author: Lukas Malek
Email: malek.luky@gmail.com
Date: February 2023</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">"""
Project: Artificial Intelligence for Robotics
Author: Lukas Malek
Email: malek.luky@gmail.com
Date: February 2023
"""

import math
import time
import numpy as np
import threading as thread

#hexapod robot 
import hexapod_sim.HexapodHAL as hexapodhal

#cpg network
import cpg.oscilator_network as osc

#import robot parameters
from HexapodRobotConst import *

#import controller
import HexapodController as cntrl

#import messages
from messages import *

class HexapodRobot:
    def __init__(self, robot_id):
        """Hexapod controller class constructor
        """
        #robotHAL instance
        self.robot = hexapodhal.HexapodHAL(robot_id, TIME_FRAME)
        #controller instance
        self.controller = cntrl.HexapodController()
        self.control_method = self.controller.goto

        #gait parametrization
        self.v_left = 0
        self.v_right = 0
        
        #stride_length
        self.stride_length = 1
        #stride_height
        self.stride_height = 1

        #locomotion and navigation variables
        self.locomotion_stop = False
        self.locomotion_lock = thread.Lock()     #mutex for access to turn commands
        self.locomotion_status = False

        self.navigation_stop = False
        self.navigation_lock = thread.Lock()   #mutex for access to navigation coordinates
        self.navigation_status = False 
        self.navigation_goal = None

        #simulator data
        self.odometry_ = None
        self.collision_ = None
        self.laser_scan_ = None

    ########################################################################

    def turn_on(self):
        """Method to drive the robot into the default position
        """
        #read out the current pose of the robot
        configuration = self.robot.get_all_servo_position()

        #interpolate to the default position
        INTERPOLATION_TIME = 3000 #ms
        interpolation_steps = int(INTERPOLATION_TIME/TIME_FRAME)

        speed = np.zeros(18)
        for i in range(0,18):
            speed[i] = (SERVOS_BASE[i]-configuration[i])/interpolation_steps
        
        #execute the motion
        for t in range(0, interpolation_steps):
            self.robot.set_all_servo_position(configuration + t*speed)


    def turn_off(self):
        """Method to turn off the robot
        """
        self.robot.stop_simulation()

    ########################################################################
    ## LOCOMOTION
    ########################################################################

    def start_locomotion(self):
        """Method to start the robot locomotion 
        """
        #starting the locomotion thread if it is not running
        if self.locomotion_status == False: 
            try:
                self.locomotion_stop = False
                locomotion_thread = thread.Thread(target=self.locomotion)
            except:
                print(time.strftime("%H:%M:%S"),"Error: unable to start locomotion thread")
                sys.exit(1)

            locomotion_thread.start()
        else:
            print(time.strftime("%H:%M:%S"),"The locomotion is already running")

    def stop_locomotion(self):
        """Method to stop the locomotion
        """
        print(time.strftime("%H:%M:%S"),"Stopping the locomotion thread")
        self.locomotion_stop = True

    def locomotion(self):
        """Method for locomotion control of the hexapod robot
        """
        self.locomotion_status = True
        
        #cpg network instantiation
        cpg = osc.OscilatorNetwork(6)
        cpg.change_gait(osc.TRIPOD_GAIT_WEIGHTS)

        coxa_angles= [0, 0, 0, 0, 0, 0]
        cycle_length = [0, 0, 0, 0, 0, 0]
       
        last_timestamp = 0
        #main locomotion control loop
        while not self.locomotion_stop:
            # steering - acquire left and right steering speeds
            self.locomotion_lock.acquire()
            left = np.min([1, np.max([-1, self.v_left])])
            right = np.min([1, np.max([-1, self.v_right])])
            self.locomotion_lock.release()

            coxa_dir = [left, left, left, right, right, right]      #set directions for individual legs

            #next step of CPG
            cycle = cpg.oscilate_all_CPGs()
            #read the state of the network
            data = cpg.get_last_values()

            #reset coxa angles if new cycle is detected
            for i in range(0, 6):
                cycle_length[i] += 1
                if cycle[i] == True:
                    coxa_angles[i]= -((cycle_length[i]-2)/2)*COXA_MAX
                    cycle_length[i] = 0

            angles = np.zeros(18)
            #calculate individual joint angles for each of six legs
            for i in range(0, 6):
                femur_val = FEMUR_MAX*data[i] #calculation of femur angle
                if femur_val &lt; 0:
                    coxa_angles[i] -= coxa_dir[i]*COXA_MAX  #calculation of coxa angle -&gt; stride phase
                    femur_val *= 0.025
                else:
                    coxa_angles[i] += coxa_dir[i]*COXA_MAX  #calculation of coxa angle -&gt; stance phase
                
                coxa_val = coxa_angles[i]
                tibia_val = -TIBIA_MAX*data[i]       #calculation of tibia angle
                    
                #set position of each servo
                angles[COXA_SERVOS[i] - 1] = SIGN_SERVOS[i]*coxa_val*self.stride_length + COXA_OFFSETS[i]
                angles[FEMUR_SERVOS[i] - 1] = SIGN_SERVOS[i]*femur_val*self.stride_height + FEMUR_OFFSETS[i]
                angles[TIBIA_SERVOS[i] - 1] = SIGN_SERVOS[i]*tibia_val*self.stride_height + TIBIA_OFFSETS[i]
                    
            #set all servos simultaneously
            self.robot.set_all_servo_position(angles)

            # GET DATA FROM SIMULATOR
            self.odometry_ = self.robot.get_robot_odometry()
            self.collision_ = self.robot.get_robot_collision()
            self.laser_scan_ = self.robot.get_laser_scan()

            time.sleep(TIME_FRAME/100.0)
            
        self.locomotion_status = False    
    
    def move(self, cmd):
        """Function to set diferential steering command
        Args:
            cmd: Twist velocity command
        """
        if cmd == None:
            left = 0
            right = 0
            self.navigation_goal = None
        else:
            #translate the velocity command into the differential steering command
            linear_x = np.min([np.max([cmd.linear.x,-1]),1])
            linear_y = np.min([np.max([cmd.linear.y,-1]),1])
            angular_z = np.min([np.max([cmd.angular.z,-1]),1])
            
            right = (linear_x + angular_z)/2
            left = linear_x - right

        self.locomotion_lock.acquire()
        self.v_left = SPEEDUP*left
        self.v_right = SPEEDUP*right
        self.locomotion_lock.release()

    ########################################################################
    ## NAVIGATION
    ########################################################################

    def start_navigation(self):
        """Method to start the navigation thread, that will guide the robot towards the goal set using the goto function
        """
        #starting the navigation thread if it is not running
        if self.navigation_status == False: 
            print(time.strftime("%H:%M:%S"),"Starting navigation thread")
            try:
                self.navigation_stop = False
                navigation_thread = thread.Thread(target=self.navigation)
            except:
                print(time.strftime("%H:%M:%S"),"Error: unable to start navigation thread")
                sys.exit(1)

            navigation_thread.start()
        else:
            print(time.strftime("%H:%M:%S"),"The navigation is already running")
        
    def stop_navigation(self):
        """
        Stop the navigation thread
        """
        print(time.strftime("%H:%M:%S"),"Stopping the navigation thread")
        self.navigation_stop = True
        self.locomotion_stop = True

    def navigation(self):
        """Method for the navigation control towards a given goal
        """
        self.navigation_status = True

        #start the locomotion if it is not running
        if self.locomotion_status == False:
            print(time.strftime("%H:%M:%S"),"Starting locomotion thread")
            self.start_locomotion()

        #navigation loop
        cmd = None
        while not self.navigation_stop:
            #stop the robot
            if self.control_method == self.controller.stop:
                cmd = self.control_method()
        
            #open-loop control
            elif self.control_method == self.controller.goto:
                cmd = self.control_method(
                            goal = self.navigation_goal,
                            odometry = self.odometry_,
                            collision = self.collision_
                      )
            #reactive control
            elif self.control_method == self.controller.goto_reactive:
                cmd = self.control_method(
                            goal = self.navigation_goal,
                            odometry = self.odometry_,
                            collision = self.collision_,
                            laser_scan = self.laser_scan_
                      )

            #drive the robot using the selected command
            self.move(cmd)
            #pause for a bit 
            time.sleep(0.1)

        self.navigation_status = False
            
    def goto(self, goal):
        """open-loop navigation towards a selected navigational goal
        Args:
            goal: Pose of the robot goal 
        """
        self.control_method = self.controller.goto
        self.navigation_lock.acquire()
        self.navigation_goal = goal
        self.navigation_lock.release()

    def stop(self):
        """open-loop navigation towards a selected navigational goal
        Args:
            goal: Pose of the robot goal 
        """
        self.control_method = self.controller.stop
        self.navigation_lock.acquire()
        self.navigation_goal = None
        self.navigation_lock.release()

    def goto_reactive(self, goal):
        """navigation towards a selected navigational goal while avoiding obstacles
        Args:
            goal: Pose of the robot goal 
        """
        self.control_method = self.controller.goto_reactive
        self.navigation_lock.acquire()
        self.navigation_goal = goal
        self.navigation_lock.release()

if __name__=="__main__":
    robot = HexapodController()
    #drive the robot into the default position
    robot.turn_on()
    time.sleep(3)

    #test the locomotion
    robot.start_locomotion()
    time.sleep(3)
    
    #velocity command
    #go straight
    cmd = Twist()
    cmd.linear.x = 1.0

    robot.move(cmd)
    time.sleep(10)

    #turn
    cmd.linear.x = 0.0
    cmd.angular.z = 1.0
    robot.move(cmd)
    time.sleep(10)
    
    robot.stop_locomotion()
    robot.turn_off()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="HexapodRobot.HexapodRobot"><code class="flex name class">
<span>class <span class="ident">HexapodRobot</span></span>
<span>(</span><span>robot_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Hexapod controller class constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HexapodRobot:
    def __init__(self, robot_id):
        """Hexapod controller class constructor
        """
        #robotHAL instance
        self.robot = hexapodhal.HexapodHAL(robot_id, TIME_FRAME)
        #controller instance
        self.controller = cntrl.HexapodController()
        self.control_method = self.controller.goto

        #gait parametrization
        self.v_left = 0
        self.v_right = 0
        
        #stride_length
        self.stride_length = 1
        #stride_height
        self.stride_height = 1

        #locomotion and navigation variables
        self.locomotion_stop = False
        self.locomotion_lock = thread.Lock()     #mutex for access to turn commands
        self.locomotion_status = False

        self.navigation_stop = False
        self.navigation_lock = thread.Lock()   #mutex for access to navigation coordinates
        self.navigation_status = False 
        self.navigation_goal = None

        #simulator data
        self.odometry_ = None
        self.collision_ = None
        self.laser_scan_ = None

    ########################################################################

    def turn_on(self):
        """Method to drive the robot into the default position
        """
        #read out the current pose of the robot
        configuration = self.robot.get_all_servo_position()

        #interpolate to the default position
        INTERPOLATION_TIME = 3000 #ms
        interpolation_steps = int(INTERPOLATION_TIME/TIME_FRAME)

        speed = np.zeros(18)
        for i in range(0,18):
            speed[i] = (SERVOS_BASE[i]-configuration[i])/interpolation_steps
        
        #execute the motion
        for t in range(0, interpolation_steps):
            self.robot.set_all_servo_position(configuration + t*speed)


    def turn_off(self):
        """Method to turn off the robot
        """
        self.robot.stop_simulation()

    ########################################################################
    ## LOCOMOTION
    ########################################################################

    def start_locomotion(self):
        """Method to start the robot locomotion 
        """
        #starting the locomotion thread if it is not running
        if self.locomotion_status == False: 
            try:
                self.locomotion_stop = False
                locomotion_thread = thread.Thread(target=self.locomotion)
            except:
                print(time.strftime("%H:%M:%S"),"Error: unable to start locomotion thread")
                sys.exit(1)

            locomotion_thread.start()
        else:
            print(time.strftime("%H:%M:%S"),"The locomotion is already running")

    def stop_locomotion(self):
        """Method to stop the locomotion
        """
        print(time.strftime("%H:%M:%S"),"Stopping the locomotion thread")
        self.locomotion_stop = True

    def locomotion(self):
        """Method for locomotion control of the hexapod robot
        """
        self.locomotion_status = True
        
        #cpg network instantiation
        cpg = osc.OscilatorNetwork(6)
        cpg.change_gait(osc.TRIPOD_GAIT_WEIGHTS)

        coxa_angles= [0, 0, 0, 0, 0, 0]
        cycle_length = [0, 0, 0, 0, 0, 0]
       
        last_timestamp = 0
        #main locomotion control loop
        while not self.locomotion_stop:
            # steering - acquire left and right steering speeds
            self.locomotion_lock.acquire()
            left = np.min([1, np.max([-1, self.v_left])])
            right = np.min([1, np.max([-1, self.v_right])])
            self.locomotion_lock.release()

            coxa_dir = [left, left, left, right, right, right]      #set directions for individual legs

            #next step of CPG
            cycle = cpg.oscilate_all_CPGs()
            #read the state of the network
            data = cpg.get_last_values()

            #reset coxa angles if new cycle is detected
            for i in range(0, 6):
                cycle_length[i] += 1
                if cycle[i] == True:
                    coxa_angles[i]= -((cycle_length[i]-2)/2)*COXA_MAX
                    cycle_length[i] = 0

            angles = np.zeros(18)
            #calculate individual joint angles for each of six legs
            for i in range(0, 6):
                femur_val = FEMUR_MAX*data[i] #calculation of femur angle
                if femur_val &lt; 0:
                    coxa_angles[i] -= coxa_dir[i]*COXA_MAX  #calculation of coxa angle -&gt; stride phase
                    femur_val *= 0.025
                else:
                    coxa_angles[i] += coxa_dir[i]*COXA_MAX  #calculation of coxa angle -&gt; stance phase
                
                coxa_val = coxa_angles[i]
                tibia_val = -TIBIA_MAX*data[i]       #calculation of tibia angle
                    
                #set position of each servo
                angles[COXA_SERVOS[i] - 1] = SIGN_SERVOS[i]*coxa_val*self.stride_length + COXA_OFFSETS[i]
                angles[FEMUR_SERVOS[i] - 1] = SIGN_SERVOS[i]*femur_val*self.stride_height + FEMUR_OFFSETS[i]
                angles[TIBIA_SERVOS[i] - 1] = SIGN_SERVOS[i]*tibia_val*self.stride_height + TIBIA_OFFSETS[i]
                    
            #set all servos simultaneously
            self.robot.set_all_servo_position(angles)

            # GET DATA FROM SIMULATOR
            self.odometry_ = self.robot.get_robot_odometry()
            self.collision_ = self.robot.get_robot_collision()
            self.laser_scan_ = self.robot.get_laser_scan()

            time.sleep(TIME_FRAME/100.0)
            
        self.locomotion_status = False    
    
    def move(self, cmd):
        """Function to set diferential steering command
        Args:
            cmd: Twist velocity command
        """
        if cmd == None:
            left = 0
            right = 0
            self.navigation_goal = None
        else:
            #translate the velocity command into the differential steering command
            linear_x = np.min([np.max([cmd.linear.x,-1]),1])
            linear_y = np.min([np.max([cmd.linear.y,-1]),1])
            angular_z = np.min([np.max([cmd.angular.z,-1]),1])
            
            right = (linear_x + angular_z)/2
            left = linear_x - right

        self.locomotion_lock.acquire()
        self.v_left = SPEEDUP*left
        self.v_right = SPEEDUP*right
        self.locomotion_lock.release()

    ########################################################################
    ## NAVIGATION
    ########################################################################

    def start_navigation(self):
        """Method to start the navigation thread, that will guide the robot towards the goal set using the goto function
        """
        #starting the navigation thread if it is not running
        if self.navigation_status == False: 
            print(time.strftime("%H:%M:%S"),"Starting navigation thread")
            try:
                self.navigation_stop = False
                navigation_thread = thread.Thread(target=self.navigation)
            except:
                print(time.strftime("%H:%M:%S"),"Error: unable to start navigation thread")
                sys.exit(1)

            navigation_thread.start()
        else:
            print(time.strftime("%H:%M:%S"),"The navigation is already running")
        
    def stop_navigation(self):
        """
        Stop the navigation thread
        """
        print(time.strftime("%H:%M:%S"),"Stopping the navigation thread")
        self.navigation_stop = True
        self.locomotion_stop = True

    def navigation(self):
        """Method for the navigation control towards a given goal
        """
        self.navigation_status = True

        #start the locomotion if it is not running
        if self.locomotion_status == False:
            print(time.strftime("%H:%M:%S"),"Starting locomotion thread")
            self.start_locomotion()

        #navigation loop
        cmd = None
        while not self.navigation_stop:
            #stop the robot
            if self.control_method == self.controller.stop:
                cmd = self.control_method()
        
            #open-loop control
            elif self.control_method == self.controller.goto:
                cmd = self.control_method(
                            goal = self.navigation_goal,
                            odometry = self.odometry_,
                            collision = self.collision_
                      )
            #reactive control
            elif self.control_method == self.controller.goto_reactive:
                cmd = self.control_method(
                            goal = self.navigation_goal,
                            odometry = self.odometry_,
                            collision = self.collision_,
                            laser_scan = self.laser_scan_
                      )

            #drive the robot using the selected command
            self.move(cmd)
            #pause for a bit 
            time.sleep(0.1)

        self.navigation_status = False
            
    def goto(self, goal):
        """open-loop navigation towards a selected navigational goal
        Args:
            goal: Pose of the robot goal 
        """
        self.control_method = self.controller.goto
        self.navigation_lock.acquire()
        self.navigation_goal = goal
        self.navigation_lock.release()

    def stop(self):
        """open-loop navigation towards a selected navigational goal
        Args:
            goal: Pose of the robot goal 
        """
        self.control_method = self.controller.stop
        self.navigation_lock.acquire()
        self.navigation_goal = None
        self.navigation_lock.release()

    def goto_reactive(self, goal):
        """navigation towards a selected navigational goal while avoiding obstacles
        Args:
            goal: Pose of the robot goal 
        """
        self.control_method = self.controller.goto_reactive
        self.navigation_lock.acquire()
        self.navigation_goal = goal
        self.navigation_lock.release()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="HexapodRobot.HexapodRobot.goto"><code class="name flex">
<span>def <span class="ident">goto</span></span>(<span>self, goal)</span>
</code></dt>
<dd>
<div class="desc"><p>open-loop navigation towards a selected navigational goal</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>goal</code></strong></dt>
<dd>Pose of the robot goal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto(self, goal):
    """open-loop navigation towards a selected navigational goal
    Args:
        goal: Pose of the robot goal 
    """
    self.control_method = self.controller.goto
    self.navigation_lock.acquire()
    self.navigation_goal = goal
    self.navigation_lock.release()</code></pre>
</details>
</dd>
<dt id="HexapodRobot.HexapodRobot.goto_reactive"><code class="name flex">
<span>def <span class="ident">goto_reactive</span></span>(<span>self, goal)</span>
</code></dt>
<dd>
<div class="desc"><p>navigation towards a selected navigational goal while avoiding obstacles</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>goal</code></strong></dt>
<dd>Pose of the robot goal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto_reactive(self, goal):
    """navigation towards a selected navigational goal while avoiding obstacles
    Args:
        goal: Pose of the robot goal 
    """
    self.control_method = self.controller.goto_reactive
    self.navigation_lock.acquire()
    self.navigation_goal = goal
    self.navigation_lock.release()</code></pre>
</details>
</dd>
<dt id="HexapodRobot.HexapodRobot.locomotion"><code class="name flex">
<span>def <span class="ident">locomotion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for locomotion control of the hexapod robot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def locomotion(self):
    """Method for locomotion control of the hexapod robot
    """
    self.locomotion_status = True
    
    #cpg network instantiation
    cpg = osc.OscilatorNetwork(6)
    cpg.change_gait(osc.TRIPOD_GAIT_WEIGHTS)

    coxa_angles= [0, 0, 0, 0, 0, 0]
    cycle_length = [0, 0, 0, 0, 0, 0]
   
    last_timestamp = 0
    #main locomotion control loop
    while not self.locomotion_stop:
        # steering - acquire left and right steering speeds
        self.locomotion_lock.acquire()
        left = np.min([1, np.max([-1, self.v_left])])
        right = np.min([1, np.max([-1, self.v_right])])
        self.locomotion_lock.release()

        coxa_dir = [left, left, left, right, right, right]      #set directions for individual legs

        #next step of CPG
        cycle = cpg.oscilate_all_CPGs()
        #read the state of the network
        data = cpg.get_last_values()

        #reset coxa angles if new cycle is detected
        for i in range(0, 6):
            cycle_length[i] += 1
            if cycle[i] == True:
                coxa_angles[i]= -((cycle_length[i]-2)/2)*COXA_MAX
                cycle_length[i] = 0

        angles = np.zeros(18)
        #calculate individual joint angles for each of six legs
        for i in range(0, 6):
            femur_val = FEMUR_MAX*data[i] #calculation of femur angle
            if femur_val &lt; 0:
                coxa_angles[i] -= coxa_dir[i]*COXA_MAX  #calculation of coxa angle -&gt; stride phase
                femur_val *= 0.025
            else:
                coxa_angles[i] += coxa_dir[i]*COXA_MAX  #calculation of coxa angle -&gt; stance phase
            
            coxa_val = coxa_angles[i]
            tibia_val = -TIBIA_MAX*data[i]       #calculation of tibia angle
                
            #set position of each servo
            angles[COXA_SERVOS[i] - 1] = SIGN_SERVOS[i]*coxa_val*self.stride_length + COXA_OFFSETS[i]
            angles[FEMUR_SERVOS[i] - 1] = SIGN_SERVOS[i]*femur_val*self.stride_height + FEMUR_OFFSETS[i]
            angles[TIBIA_SERVOS[i] - 1] = SIGN_SERVOS[i]*tibia_val*self.stride_height + TIBIA_OFFSETS[i]
                
        #set all servos simultaneously
        self.robot.set_all_servo_position(angles)

        # GET DATA FROM SIMULATOR
        self.odometry_ = self.robot.get_robot_odometry()
        self.collision_ = self.robot.get_robot_collision()
        self.laser_scan_ = self.robot.get_laser_scan()

        time.sleep(TIME_FRAME/100.0)
        
    self.locomotion_status = False    </code></pre>
</details>
</dd>
<dt id="HexapodRobot.HexapodRobot.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, cmd)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to set diferential steering command</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmd</code></strong></dt>
<dd>Twist velocity command</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self, cmd):
    """Function to set diferential steering command
    Args:
        cmd: Twist velocity command
    """
    if cmd == None:
        left = 0
        right = 0
        self.navigation_goal = None
    else:
        #translate the velocity command into the differential steering command
        linear_x = np.min([np.max([cmd.linear.x,-1]),1])
        linear_y = np.min([np.max([cmd.linear.y,-1]),1])
        angular_z = np.min([np.max([cmd.angular.z,-1]),1])
        
        right = (linear_x + angular_z)/2
        left = linear_x - right

    self.locomotion_lock.acquire()
    self.v_left = SPEEDUP*left
    self.v_right = SPEEDUP*right
    self.locomotion_lock.release()</code></pre>
</details>
</dd>
<dt id="HexapodRobot.HexapodRobot.navigation"><code class="name flex">
<span>def <span class="ident">navigation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for the navigation control towards a given goal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def navigation(self):
    """Method for the navigation control towards a given goal
    """
    self.navigation_status = True

    #start the locomotion if it is not running
    if self.locomotion_status == False:
        print(time.strftime("%H:%M:%S"),"Starting locomotion thread")
        self.start_locomotion()

    #navigation loop
    cmd = None
    while not self.navigation_stop:
        #stop the robot
        if self.control_method == self.controller.stop:
            cmd = self.control_method()
    
        #open-loop control
        elif self.control_method == self.controller.goto:
            cmd = self.control_method(
                        goal = self.navigation_goal,
                        odometry = self.odometry_,
                        collision = self.collision_
                  )
        #reactive control
        elif self.control_method == self.controller.goto_reactive:
            cmd = self.control_method(
                        goal = self.navigation_goal,
                        odometry = self.odometry_,
                        collision = self.collision_,
                        laser_scan = self.laser_scan_
                  )

        #drive the robot using the selected command
        self.move(cmd)
        #pause for a bit 
        time.sleep(0.1)

    self.navigation_status = False</code></pre>
</details>
</dd>
<dt id="HexapodRobot.HexapodRobot.start_locomotion"><code class="name flex">
<span>def <span class="ident">start_locomotion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to start the robot locomotion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_locomotion(self):
    """Method to start the robot locomotion 
    """
    #starting the locomotion thread if it is not running
    if self.locomotion_status == False: 
        try:
            self.locomotion_stop = False
            locomotion_thread = thread.Thread(target=self.locomotion)
        except:
            print(time.strftime("%H:%M:%S"),"Error: unable to start locomotion thread")
            sys.exit(1)

        locomotion_thread.start()
    else:
        print(time.strftime("%H:%M:%S"),"The locomotion is already running")</code></pre>
</details>
</dd>
<dt id="HexapodRobot.HexapodRobot.start_navigation"><code class="name flex">
<span>def <span class="ident">start_navigation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to start the navigation thread, that will guide the robot towards the goal set using the goto function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_navigation(self):
    """Method to start the navigation thread, that will guide the robot towards the goal set using the goto function
    """
    #starting the navigation thread if it is not running
    if self.navigation_status == False: 
        print(time.strftime("%H:%M:%S"),"Starting navigation thread")
        try:
            self.navigation_stop = False
            navigation_thread = thread.Thread(target=self.navigation)
        except:
            print(time.strftime("%H:%M:%S"),"Error: unable to start navigation thread")
            sys.exit(1)

        navigation_thread.start()
    else:
        print(time.strftime("%H:%M:%S"),"The navigation is already running")</code></pre>
</details>
</dd>
<dt id="HexapodRobot.HexapodRobot.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>open-loop navigation towards a selected navigational goal</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>goal</code></strong></dt>
<dd>Pose of the robot goal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    """open-loop navigation towards a selected navigational goal
    Args:
        goal: Pose of the robot goal 
    """
    self.control_method = self.controller.stop
    self.navigation_lock.acquire()
    self.navigation_goal = None
    self.navigation_lock.release()</code></pre>
</details>
</dd>
<dt id="HexapodRobot.HexapodRobot.stop_locomotion"><code class="name flex">
<span>def <span class="ident">stop_locomotion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to stop the locomotion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_locomotion(self):
    """Method to stop the locomotion
    """
    print(time.strftime("%H:%M:%S"),"Stopping the locomotion thread")
    self.locomotion_stop = True</code></pre>
</details>
</dd>
<dt id="HexapodRobot.HexapodRobot.stop_navigation"><code class="name flex">
<span>def <span class="ident">stop_navigation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the navigation thread</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_navigation(self):
    """
    Stop the navigation thread
    """
    print(time.strftime("%H:%M:%S"),"Stopping the navigation thread")
    self.navigation_stop = True
    self.locomotion_stop = True</code></pre>
</details>
</dd>
<dt id="HexapodRobot.HexapodRobot.turn_off"><code class="name flex">
<span>def <span class="ident">turn_off</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to turn off the robot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_off(self):
    """Method to turn off the robot
    """
    self.robot.stop_simulation()</code></pre>
</details>
</dd>
<dt id="HexapodRobot.HexapodRobot.turn_on"><code class="name flex">
<span>def <span class="ident">turn_on</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to drive the robot into the default position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_on(self):
    """Method to drive the robot into the default position
    """
    #read out the current pose of the robot
    configuration = self.robot.get_all_servo_position()

    #interpolate to the default position
    INTERPOLATION_TIME = 3000 #ms
    interpolation_steps = int(INTERPOLATION_TIME/TIME_FRAME)

    speed = np.zeros(18)
    for i in range(0,18):
        speed[i] = (SERVOS_BASE[i]-configuration[i])/interpolation_steps
    
    #execute the motion
    for t in range(0, interpolation_steps):
        self.robot.set_all_servo_position(configuration + t*speed)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a href="#HexapodRobot.HexapodRobot" title="HexapodRobot.HexapodRobot">HexapodRobot</a></code></h4>
<ul class="two-column">
<li><code><a href="#HexapodRobot.HexapodRobot.goto" title="HexapodRobot.HexapodRobot.goto">goto</a></code></li>
<li><code><a href="#HexapodRobot.HexapodRobot.goto_reactive" title="HexapodRobot.HexapodRobot.goto_reactive">goto_reactive</a></code></li>
<li><code><a href="#HexapodRobot.HexapodRobot.locomotion" title="HexapodRobot.HexapodRobot.locomotion">locomotion</a></code></li>
<li><code><a href="#HexapodRobot.HexapodRobot.move" title="HexapodRobot.HexapodRobot.move">move</a></code></li>
<li><code><a href="#HexapodRobot.HexapodRobot.navigation" title="HexapodRobot.HexapodRobot.navigation">navigation</a></code></li>
<li><code><a href="#HexapodRobot.HexapodRobot.start_locomotion" title="HexapodRobot.HexapodRobot.start_locomotion">start_locomotion</a></code></li>
<li><code><a href="#HexapodRobot.HexapodRobot.start_navigation" title="HexapodRobot.HexapodRobot.start_navigation">start_navigation</a></code></li>
<li><code><a href="#HexapodRobot.HexapodRobot.stop" title="HexapodRobot.HexapodRobot.stop">stop</a></code></li>
<li><code><a href="#HexapodRobot.HexapodRobot.stop_locomotion" title="HexapodRobot.HexapodRobot.stop_locomotion">stop_locomotion</a></code></li>
<li><code><a href="#HexapodRobot.HexapodRobot.stop_navigation" title="HexapodRobot.HexapodRobot.stop_navigation">stop_navigation</a></code></li>
<li><code><a href="#HexapodRobot.HexapodRobot.turn_off" title="HexapodRobot.HexapodRobot.turn_off">turn_off</a></code></li>
<li><code><a href="#HexapodRobot.HexapodRobot.turn_on" title="HexapodRobot.HexapodRobot.turn_on">turn_on</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>